response.getHeaderNames().forEach(header ->
        log.info("   üì§ {}: {}", header, response.getHeader(header))
    );


Collection<String> headers = response.getHeaders("Set-Cookie");
    if (!headers.isEmpty()) {
        log.info("üîπ Cookies enviadas en la respuesta:");
        for (String header : headers) {
            log.info("   üç™ Set-Cookie: {}", header);
        }
    } else {
        log.warn("‚ö†Ô∏è No se encontraron cookies en la respuesta.");
    }


@RestController
@RequestMapping("/auth")
public class AuthController {

    @GetMapping("/token")
    public ResponseEntity<?> getAccessToken(HttpServletRequest request) {
        // Obtener TODAS las cookies y loguearlas
        Cookie[] cookies = request.getCookies();
        if (cookies == null) {
            log.warn("‚ùå No se encontraron cookies en la solicitud.");
            return ResponseEntity.status(401).body("{\"error\": \"No cookies found\"}");
        }

        // Log de todas las cookies recibidas
        for (Cookie cookie : cookies) {
            log.info("üìù Cookie recibida: {} = {}", cookie.getName(), cookie.getValue());
        }

        // Buscar la cookie "access_token"
        Optional<Cookie> accessTokenCookie = Arrays.stream(cookies)
                .filter(cookie -> "access_token".equals(cookie.getName()))
                .findFirst();

        if (accessTokenCookie.isPresent()) {
            String token = accessTokenCookie.get().getValue();
            log.info("‚úÖ Access Token encontrado en la cookie.");
            return ResponseEntity.ok().body("{\"access_token\": \"" + token + "\"}");
        } else {
            log.warn("‚ö†Ô∏è No se encontr√≥ la cookie access_token.");
            return ResponseEntity.status(401).body("{\"error\": \"No token found\"}");
        }
    }
}


//esto es para quitar el jsession id
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .cors(cors -> cors.configurationSource(corsConfigurationSource()))
        .csrf(csrf -> csrf.disable())
        .authorizeHttpRequests(auth -> auth
            .requestMatchers("/auth/token").authenticated() // Solo usuarios autenticados pueden obtener el token
            .requestMatchers("/admin/**").authenticated()  // Admin requiere autenticaci√≥n
            .anyRequest().permitAll()
        )
        .sessionManagement(session -> session
            .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) // Permite sesiones solo si son necesarias
        )
        .oauth2ResourceServer(oauth2 -> oauth2.jwt());

    return http.build();
}


const express = require('express');
const request = require('request');

const app = express();
const PORT = 4000;

app.get('/callback', (req, res) => {
    console.log('Interceptando redirecci√≥n desde QA...');
    const queryParams = req.originalUrl.split('?')[1] || '';
    const localUrl = `http://localhost:3000/callback?${queryParams}`;
    console.log(`Redirigiendo a: ${localUrl}`);

    request(localUrl, (error, response, body) => {
        if (error) {
            console.error('Error al reenviar:', error);
            return res.status(500).send('Error en la redirecci√≥n.');
        }
        res.send(body);
    });
});

app.listen(PORT, () => {
    console.log(`Servidor puente corriendo en http://localhost:${PORT}`);
});



package com.bos.unison.wfsextapi.controller;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;
import java.util.Optional;

@RestController
@RequestMapping("/auth")
public class AuthController {

    @GetMapping("/token")
    public ResponseEntity<?> getAccessToken(HttpServletRequest request) {
        // Buscar la cookie "access_token"
        Optional<Cookie> accessTokenCookie = Arrays.stream(request.getCookies())
                .filter(cookie -> "access_token".equals(cookie.getName()))
                .findFirst();

        if (accessTokenCookie.isPresent()) {
            String token = accessTokenCookie.get().getValue();
            return ResponseEntity.ok().body("{\"access_token\": \"" + token + "\"}");
        } else {
            return ResponseEntity.status(401).body("{\"error\": \"No token found\"}");
        }
    }
}



response.setHeader("Access-Control-Allow-Origin", origin);
    response.setHeader("Access-Control-Allow-Credentials", "true");
    response.setHeader("Access-Control-Expose-Headers", "Set-Cookie");
    response.setHeader("Vary", "Origin");


@Override
public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException {

    log.info("*** CustomAuthenticationSuccessHandler ***");

    SecurityContextHolder.getContext().setAuthentication(authentication);

    // Obtener el token JWT de la autenticaci√≥n
    String token = ((OidcUser) authentication.getPrincipal()).getIdToken().getTokenValue();

    // Configurar la cookie con el Access Token
    Cookie cookie = new Cookie("access_token", token);
    cookie.setHttpOnly(true); // Evita acceso desde JavaScript
    cookie.setSecure(true);   // Solo en HTTPS
    cookie.setPath("/");      // Disponible en todo el dominio
    cookie.setDomain(".frontend.com"); // Permitir que el frontend React lo use
    response.addCookie(cookie);

    // Redirigir seg√∫n el rol del usuario
    if (authentication.getAuthorities().contains(new SimpleGrantedAuthority("ROLE_ADMIN"))) {
        response.sendRedirect("/admin");
    } else {
        response.sendRedirect("https://frontend.com/home");
    }
}
