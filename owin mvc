protected void Application_BeginRequest()
{
    try
    {
        var userLanguages = HttpContext.Current?.Request?.UserLanguages;
        string cultureName = userLanguages != null && userLanguages.Length > 0
            ? userLanguages[0]
            : "es-CO"; // Valor por defecto

        // Validar contra lista de culturas instaladas
        var availableCultures = CultureInfo.GetCultures(CultureTypes.AllCultures)
                                           .Select(c => c.Name)
                                           .ToHashSet(StringComparer.OrdinalIgnoreCase);

        if (!availableCultures.Contains(cultureName))
        {
            cultureName = "es-CO"; // fallback seguro
        }

        var culture = new CultureInfo(cultureName);
        Thread.CurrentThread.CurrentCulture = culture;
        Thread.CurrentThread.CurrentUICulture = culture;
    }
    catch
    {
        var fallback = new CultureInfo("es-CO");
        Thread.CurrentThread.CurrentCulture = fallback;
        Thread.CurrentThread.CurrentUICulture = fallback;
    }
}



protected void Application_BeginRequest()
{
    var userLanguages = HttpContext.Current?.Request?.UserLanguages;

    if (userLanguages != null && userLanguages.Length > 0)
    {
        var cultureName = userLanguages[0];

        try
        {
            // Intenta asignar la cultura preferida del navegador
            var culture = CultureInfo.CreateSpecificCulture(cultureName);
            Thread.CurrentThread.CurrentCulture = culture;
            Thread.CurrentThread.CurrentUICulture = culture;
        }
        catch (CultureNotFoundException)
        {
            // Si es inv√°lida, asigna una segura por defecto (es-CO, en-US, etc.)
            var defaultCulture = new CultureInfo("es-CO");
            Thread.CurrentThread.CurrentCulture = defaultCulture;
            Thread.CurrentThread.CurrentUICulture = defaultCulture;
        }
    }
    else
    {
        // Si no hay idioma especificado, tambi√©n usa la cultura por defecto
        var defaultCulture = new CultureInfo("es-CO");
        Thread.CurrentThread.CurrentCulture = defaultCulture;
        Thread.CurrentThread.CurrentUICulture = defaultCulture;
    }
}



app.Use(async (context, next) =>
{
    if (context.Request.Path.Value == "/" &&
        context.Request.QueryString.HasValue &&
        (context.Request.Query["id_token"] != null || context.Request.Query["code"] != null))
    {
        context.Response.Redirect("/signin-oidc" + context.Request.QueryString.Value);
        return;
    }

    await next();
});


<system.webServer>
  <modules runAllManagedModulesForAllRequests="true" />
  <handlers>
    <remove name="ExtensionlessUrlHandler-Integrated-4.0" />
    <add name="Owin" verb="*" path="*" type="System.Web.HttpNotFoundHandler" resourceType="Unspecified" />
  </handlers>
</system.webServer>



<modules runAllManagedModulesForAllRequests="true">



using Microsoft.IdentityModel.Protocols.OpenIdConnect;
using Microsoft.Owin;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.Cookies;
using Microsoft.Owin.Security.OpenIdConnect;
using Owin;
using System;
using System.Security.Claims;
using System.Threading.Tasks;

[assembly: OwinStartup(typeof(MyApp.Startup))]

namespace MyApp
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // Esto puede ayudarte si tienes problemas con SameSite en IIS
            app.UseKentorOwinCookieSaver();

            // Middleware de cookies (autenticaci√≥n local)
            app.UseCookieAuthentication(new CookieAuthenticationOptions
            {
                AuthenticationType = "Cookies",
                CookieSecure = CookieSecureOption.Always,
                CookieSameSite = SameSiteMode.None,
                CookieHttpOnly = true
            });

            // Middleware de OIDC
            app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
            {
                ClientId = "tu-client-id",
                Authority = "https://tu-idp.com/", // Ejemplo: https://login.microsoftonline.com/tu-tenant-id/v2.0
                RedirectUri = "https://tuapp.com/signin-oidc",
                PostLogoutRedirectUri = "https://tuapp.com/",
                ResponseType = OpenIdConnectResponseType.IdToken,
                Scope = "openid profile",

                SignInAsAuthenticationType = "Cookies",
                UseTokenLifetime = false,

                Notifications = new OpenIdConnectAuthenticationNotifications
                {
                    SecurityTokenValidated = context =>
                    {
                        // Aqu√≠ se genera la cookie
                        var identity = (ClaimsIdentity)context.AuthenticationTicket.Identity;

                        // Puedes agregar claims si necesitas
                        identity.AddClaim(new Claim("app:customClaim", "value"));

                        context.AuthenticationTicket = new AuthenticationTicket(identity, context.AuthenticationTicket.Properties);

                        // Redirigir despu√©s del login (opcional)
                        context.AuthenticationTicket.Properties.RedirectUri = "/Home/Welcome";

                        return Task.CompletedTask;
                    },

                    AuthenticationFailed = context =>
                    {
                        context.HandleResponse();
                        context.Response.Redirect("/Error?message=" + context.Exception?.Message);
                        return Task.CompletedTask;
                    }
                }
            });

            // Asegura que OWIN est√© en el paso correcto del pipeline para escribir cookies
            app.UseStageMarker(PipelineStage.Authenticate);
        }
    }
}




public class RootController : Controller
{
    public ActionResult Index()
    {
        if (User.Identity.IsAuthenticated)
        {
            return RedirectToAction("Index", "MyHome");
        }

        // Forzar challenge si no est√° autenticado
        HttpContext.GetOwinContext().Authentication.Challenge(
            new AuthenticationProperties
            {
                RedirectUri = "/"
            },
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );

        return new HttpUnauthorizedResult();
    }
}



routes.MapRoute(
    name: "Default",
    url: "",
    defaults: new { controller = "Root", action = "Index" }
);

routes.MapRoute(
    name: "Standard",
    url: "{controller}/{action}/{id}",
    defaults: new { controller = "MyHome", action = "Index", id = UrlParameter.Optional }
);

public class RouteConfig
{
    public static void RegisterRoutes(RouteCollection routes)
    {
        routes.IgnoreRoute("{resource}.axd/{*pathInfo}");

        routes.MapRoute(
            name: "MyHomeAlias",
            url: "myhome/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
        );

        routes.MapRoute(
            name: "Default",
            url: "{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
        );
    }
}




public bool WriteCore(TraceEventType eventType, int eventId, object state, Exception exception, Func<object, Exception, string> formatter)
{
    if (formatter != null)
    {
        var message = formatter(state, exception);
        var logLine = $"[{DateTime.Now:HH:mm:ss}] [{eventType}] {_name}: {message}";

        Debug.WriteLine(logLine); // Para ver en Visual Studio
        File.AppendAllText(@"C:\Logs\owin.log", logLine + "\n"); // Para guardar en archivo
    }
    return true;
}


using Microsoft.Owin.Logging;
using System;
using System.Diagnostics;

public class CustomLoggerFactory : ILoggerFactory
{
    public ILogger Create(string name)
    {
        return new CustomLogger(name);
    }
}

public class CustomLogger : ILogger
{
    private readonly string _name;

    public CustomLogger(string name)
    {
        _name = name;
    }

    public bool WriteCore(TraceEventType eventType, int eventId, object state, Exception exception, Func<object, Exception, string> formatter)
    {
        if (formatter != null)
        {
            var message = formatter(state, exception);
            Debug.WriteLine($"[{eventType}] {_name}: {message}");
        }
        return true;
    }
}


 app.SetLoggerFactory(new CustomLoggerFactory());



<appSettings>
  <add key="Microsoft.Owin" value="Verbose" />
  <add key="Microsoft.Owin.Security" value="Verbose" />
  <add key="Microsoft.Owin.Security.OpenIdConnect" value="Verbose" />
</appSettings>




RedirectToIdentityProvider = context =>
{
    var request = context.ProtocolMessage;

    // üîç 1. Tipo de solicitud
    var type = request.RequestType; // Authentication o Logout
    System.Diagnostics.Debug.WriteLine("üîÅ Tipo de solicitud: " + type);

    // üîç 2. Valores enviados al servidor de autorizaci√≥n
    System.Diagnostics.Debug.WriteLine("ClientId: " + request.ClientId);
    System.Diagnostics.Debug.WriteLine("RedirectUri: " + request.RedirectUri);
    System.Diagnostics.Debug.WriteLine("Scope: " + request.Scope);
    System.Diagnostics.Debug.WriteLine("ResponseType: " + request.ResponseType);
    System.Diagnostics.Debug.WriteLine("Nonce: " + request.Nonce);
    System.Diagnostics.Debug.WriteLine("State: " + request.State);

    // üîç 3. URL completa que se va a invocar
    System.Diagnostics.Debug.WriteLine("URL de redirecci√≥n a WAM: " + request.CreateAuthenticationRequestUrl());

    return Task.CompletedTask;
}


<system.diagnostics>
  <trace autoflush="true">
    <listeners>
      <add name="myListener" type="System.Diagnostics.TextWriterTraceListener" initializeData="owin.log" />
      <remove name="Default" />
    </listeners>
  </trace>
</system.diagnostics>

RedirectToIdentityProvider = context =>
{
    var protocolMessage = context.ProtocolMessage;

    Console.WriteLine("üîÅ RedirectToIdentityProvider activado");
    Console.WriteLine("  - RequestType: " + protocolMessage.RequestType);
    Console.WriteLine("  - ClientId: " + protocolMessage.ClientId);
    Console.WriteLine("  - RedirectUri: " + protocolMessage.RedirectUri);
    Console.WriteLine("  - Scope: " + protocolMessage.Scope);
    Console.WriteLine("  - ResponseType: " + protocolMessage.ResponseType);
    Console.WriteLine("  - State: " + protocolMessage.State);
    Console.WriteLine("  - Nonce: " + protocolMessage.Nonce);
    Console.WriteLine("  - Full URL: " + protocolMessage.CreateAuthenticationRequestUrl());

    return Task.CompletedTask;
}



app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = ConfigurationManager.AppSettings["oidc:clientId"],
    Authority = ConfigurationManager.AppSettings["oidc:authority"],
    RedirectUri = ConfigurationManager.AppSettings["oidc:redirectUri"],
    ResponseType = "code",
    Scope = "openid profile email",
    SignInAsAuthenticationType = "Cookies",

    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        AuthorizationCodeReceived = async context =>
        {
            var code = context.ProtocolMessage.Code;

            // Crea el cliente para el token endpoint
            var tokenClient = new HttpClient();

            var tokenRequest = new FormUrlEncodedContent(new Dictionary<string, string>
            {
                { "grant_type", "authorization_code" },
                { "code", code },
                { "redirect_uri", ConfigurationManager.AppSettings["oidc:redirectUri"] },
                { "client_id", ConfigurationManager.AppSettings["oidc:clientId"] },
                { "client_secret", ConfigurationManager.AppSettings["oidc:clientSecret"] }
            });

            var tokenResponse = await tokenClient.PostAsync(
                ConfigurationManager.AppSettings["oidc:tokenEndpoint"],
                tokenRequest);

            var content = await tokenResponse.Content.ReadAsStringAsync();
            var tokenData = JsonConvert.DeserializeObject<JObject>(content);

            var idToken = tokenData["id_token"].ToString();
            var accessToken = tokenData["access_token"].ToString();

            // Validar el token (aqu√≠ deber√≠as usar Microsoft.IdentityModel.Tokens)
            var handler = new JwtSecurityTokenHandler();
            var token = handler.ReadJwtToken(idToken);

            // Crear identidad
            var claims = token.Claims.ToList();
            var identity = new ClaimsIdentity(claims, "Cookies");

            context.OwinContext.Authentication.SignIn(new AuthenticationProperties
            {
                IsPersistent = true
            }, identity);

            // Indicar que ya se hizo el intercambio y no se haga autom√°tico
            context.HandleCodeRedemption(idToken, accessToken);
        }
    }
});



public class PostWamAuthFilter : ActionFilterAttribute
{
    public override void OnActionExecuting(ActionExecutingContext filterContext)
    {
        var ctx = filterContext.HttpContext;

        // Solo entra si el usuario no est√° autenticado
        if (!ctx.User.Identity.IsAuthenticated)
        {
            var request = ctx.Request;
            var code = request.QueryString["code"];
            var idToken = request.QueryString["id_token"];

            if (!string.IsNullOrEmpty(code) || !string.IsNullOrEmpty(idToken))
            {
                // Aqu√≠ deber√≠as validar el token manualmente (o al menos loguearlo)
                // Simulamos autenticaci√≥n manual para el ejemplo:

                var claims = new List<Claim>
                {
                    new Claim(ClaimTypes.NameIdentifier, "wam-user"),
                    new Claim(ClaimTypes.Name, "Usuario desde WAM"),
                    new Claim("id_token", idToken ?? ""),
                };

                var identity = new ClaimsIdentity(claims, "Cookies");
                var authManager = ctx.GetOwinContext().Authentication;

                authManager.SignIn(new AuthenticationProperties
                {
                    IsPersistent = true,
                    RedirectUri = "/Home"
                }, identity);

                // Redirige para que se aplique el nuevo contexto autenticado
                filterContext.Result = new RedirectResult("/Home");
            }
        }

        base.OnActionExecuting(filterContext);
    }
}



using Microsoft.Owin;
using Microsoft.Owin.Logging;
using Owin;
using System.Diagnostics;

[assembly: OwinStartup(typeof(YourNamespace.Startup))]

namespace YourNamespace
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            app.SetLoggerFactory(new DebugLoggerFactory());

            // Tu configuraci√≥n OWIN
        }
    }

    public class DebugLoggerFactory : ILoggerFactory
    {
        public ILogger Create(string name)
        {
            return new DebugLogger(name);
        }
    }

    public class DebugLogger : ILogger
    {
        private readonly string _name;

        public DebugLogger(string name)
        {
            _name = name;
        }

        public bool WriteCore(TraceEventType eventType, int eventId, object state, Exception exception, Func<object, Exception, string> formatter)
        {
            Debug.WriteLine($"[{eventType}] {_name} - {formatter(state, exception)}");
            return true;
        }
    }
}



<system.diagnostics>
  <sources>
    <source name="System.Net" switchValue="Verbose">
      <listeners>
        <add name="System.Net"/>
      </listeners>
    </source>
    <source name="System.Net.Http" switchValue="Verbose">
      <listeners>
        <add name="System.Net"/>
      </listeners>
    </source>
  </sources>
  <sharedListeners>
    <add name="System.Net"
         type="System.Diagnostics.TextWriterTraceListener"
         initializeData="network.log" />
  </sharedListeners>
  <trace autoflush="true" />
</system.diagnostics>


<configuration>
  <system.diagnostics>
    <sources>
      <source name="Microsoft.Owin" switchValue="Verbose">
        <listeners>
          <add name="OwinTrace" type="System.Diagnostics.TextWriterTraceListener"
               initializeData="C:\logs\owin.log" />
        </listeners>
      </source>
      <source name="Microsoft.Owin.Security" switchValue="Verbose">
        <listeners>
          <add name="OwinSecurityTrace" type="System.Diagnostics.TextWriterTraceListener"
               initializeData="C:\logs\owin-security.log" />
        </listeners>
      </source>
      <source name="System.IdentityModel.Tokens.Jwt" switchValue="Verbose">
        <listeners>
          <add name="JwtTrace" type="System.Diagnostics.TextWriterTraceListener"
               initializeData="C:\logs\jwt.log" />
        </listeners>
      </source>
    </sources>
    <trace autoflush="true" />
  </system.diagnostics>
</configuration>



app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    // Config b√°sica...

    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        RedirectToIdentityProvider = context =>
        {
            var request = context.Request;

            if (request.Method == "POST" &&
                (request.ReadFormAsync().Result.ContainsKey("id_token") ||
                 request.ReadFormAsync().Result.ContainsKey("code")))
            {
                // ‚ö†Ô∏è Aqu√≠ cancelamos el redirect autom√°tico
                context.HandleResponse();
            }

            return Task.CompletedTask;
        },

        MessageReceived = context =>
        {
            // Aqu√≠ procesas el POST y todo sigue normal
            return Task.CompletedTask;
        },

        SecurityTokenValidated = context =>
        {
            // Generar la cookie
            return Task.CompletedTask;
        }
    }
});




app.Use(async (context, next) =>
{
    await next.Invoke();

    var headers = context.Response.Headers;
    if (headers.ContainsKey("Set-Cookie"))
    {
        var cookies = headers.GetValues("Set-Cookie");
        for (int i = 0; i < cookies.Length; i++)
        {
            if (cookies[i].Contains("AspNet.Cookies"))
            {
                cookies[i] = cookies[i].Replace("SameSite=Lax", "SameSite=None");
                headers.Set("Set-Cookie", cookies[i]);
            }
        }
    }
});




@using (Html.BeginForm("ProcesarFormulario", "Home", FormMethod.Post))
{
    <label for="nombre">Nombre:</label>
    @Html.TextBox("nombre", "", new { @class = "form-control", placeholder = "Ingresa tu nombre" })

    <button type="submit" class="btn btn-primary mt-2">Enviar</button>
}
using System.Web.Mvc;

public class HomeController : Controller
{
    [HttpPost]
    public ActionResult ProcesarFormulario(string nombre)
    {
        ViewBag.Mensaje = "Hola, " + nombre;
        return View("Resultado");
    }
}
----------------------------------------------------------------------------------------------------------------------------------


‚úÖ 3. Redirigir a WAM Solo Si No Hay id_token
Para evitar que la app siga redirigiendo en un loop infinito, debemos asegurarnos de que solo se reenv√≠e a WAM cuando realmente no haya autenticaci√≥n.

üìå Modifica la l√≥gica de redirecci√≥n en Startup.cs:
app.Use(async (context, next) =>
{
    var user = context.Authentication.User;

    if (user == null || !user.Identity.IsAuthenticated)
    {
        System.Diagnostics.Debug.WriteLine("üî¥ Usuario NO autenticado, verificando si hay id_token...");

        // üîπ Verificar si hay un id_token en la respuesta
        var form = await context.Request.ReadFormAsync();
        var idToken = form["id_token"];
        
        if (!string.IsNullOrEmpty(idToken))
        {
            System.Diagnostics.Debug.WriteLine($"üîπ id_token detectado: {idToken}");
        }
        else
        {
            System.Diagnostics.Debug.WriteLine("üî¥ Redirigiendo a WAM porque no hay sesi√≥n ni token.");
            context.Authentication.Challenge(new AuthenticationProperties { RedirectUri = "/" }, "oidc");
            return;
        }
    }

    System.Diagnostics.Debug.WriteLine("‚úÖ Usuario autenticado, continuando...");
    await next();
});



----------------------------------------------------------------------------------------------------------------------------------

‚úÖ 1. Activar System.Diagnostics para Ver Detalles
Antes de hacer cambios, activa logs detallados de OWIN para ver qu√© est√° pasando.

üìå Agrega esto en web.config:

<system.diagnostics>
    <sources>
        <source name="System.IdentityModel.Tokens.Jwt" switchValue="Verbose">
            <listeners>
                <add name="JwtTrace" type="System.Diagnostics.TextWriterTraceListener" initializeData="c:\logs\jwt.log"/>
            </listeners>
        </source>
        <source name="Microsoft.Owin" switchValue="Verbose">
            <listeners>
                <add name="OwinTrace" type="System.Diagnostics.TextWriterTraceListener" initializeData="c:\logs\owin.log"/>
            </listeners>
        </source>
    </sources>
</system.diagnostics>

----------------------------------------------------------------------------------------------------------------------------------

‚úÖ 3. Revisar las Cookies de Sesi√≥n
Otro problema puede ser que la cookie de sesi√≥n no se est√© estableciendo correctamente, haciendo que la app no "recuerde" que ya se autentic√≥.

üìå Prueba forzando el almacenamiento de la cookie con UseCookieAuthentication:

app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = "Cookies",
    ExpireTimeSpan = TimeSpan.FromMinutes(60),
    SlidingExpiration = true, // üîπ Mantiene la sesi√≥n activa si el usuario sigue navegando
});


‚úÖ 2. Asegurar que el Middleware de Autenticaci√≥n No Redirija de Nuevo
Aseg√∫rate de que la l√≥gica de autenticaci√≥n en Startup.cs solo redirija cuando realmente no haya sesi√≥n.

üìå Modifica esta parte de Startup.cs para evitar el bucle:

app.Use(async (context, next) =>
{
    var user = context.Authentication.User;

    // üîπ Solo redirigir a WAM si el usuario NO est√° autenticado
    if (user == null || !user.Identity.IsAuthenticated)
    {
        context.Authentication.Challenge(new AuthenticationProperties { RedirectUri = "/" }, "oidc");
        return;
    }

    await next();
});
----------------------------------------------------------------------------------------------------------------------------------
     

using Microsoft.Owin;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.Cookies;
using Microsoft.Owin.Security.OpenIdConnect;
using Owin;
using System;
using System.Configuration;

[assembly: OwinStartup(typeof(MyApp.Startup))]

namespace MyApp
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // Usa Cookies para manejar la autenticaci√≥n de OWIN
            app.UseCookieAuthentication(new CookieAuthenticationOptions
            {
                AuthenticationType = "Cookies"
            });

            // Configurar OpenID Connect con WAM
            app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
            {
                AuthenticationType = "oidc",
                ClientId = ConfigurationManager.AppSettings["ClientId"],
                Authority = ConfigurationManager.AppSettings["Authority"], // URL del WAM
                RedirectUri = ConfigurationManager.AppSettings["RedirectUri"],
                ResponseType = "code id_token",
                Scope = "openid profile email",
                SignInAsAuthenticationType = "Cookies",
                UseTokenLifetime = false,

                Notifications = new OpenIdConnectAuthenticationNotifications
                {
                    AuthenticationFailed = context =>
                    {
                        context.HandleResponse();
                        return System.Threading.Tasks.Task.FromResult(0);
                    }
                }
            });

            // Redirige a la autenticaci√≥n al iniciar la app (sin bot√≥n de login)
            app.Use(async (context, next) =>
            {
                if (!context.Authentication.User.Identity.IsAuthenticated)
                {
                    context.Authentication.Challenge(new AuthenticationProperties { RedirectUri = "/" }, "oidc");
                    return;
                }
                await next();
            });
        }
    }
}


----------------------------------------------------------------------------------------------------------------------------------

1Ô∏è‚É£ Configurar UseCookieAuthentication Correctamente
Si OWIN no guarda la sesi√≥n, el usuario siempre parecer√° "No autenticado". Aseg√∫rate de que UseCookieAuthentication est√© configurado as√≠ en Startup.cs:

app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
    ExpireTimeSpan = System.TimeSpan.FromMinutes(60),
    SlidingExpiration = true,
    CookieHttpOnly = true,
    CookieSecure = CookieSecureOption.Always,
    CookieSameSite = SameSiteMode.Lax,
    LoginPath = new PathString("/signin-oidc"),  // üîπ Esto ayuda a OWIN a reconocer la sesi√≥n
});
}

2Ô∏è‚É£ Forzar OWIN a Validar el Token de WAM
Si SecurityTokenValidated nunca se ejecuta, significa que el token de autenticaci√≥n de WAM no est√° siendo le√≠do correctamente. Vamos a forzarlo:

üìù SecurityTokenValidated - Forzar la Sesi√≥n
SecurityTokenValidated = context =>
{
    var identity = context.AuthenticationTicket.Identity;

    Debug.WriteLine("‚úÖ OWIN: Token de seguridad validado.");
    Debug.WriteLine($"üîπ Usuario autenticado: {identity.Name}");

    // üîπ Agregar manualmente un Claim para que OWIN reconozca la sesi√≥n
    identity.AddClaim(new System.Security.Claims.Claim(System.Security.Claims.ClaimTypes.Name, identity.Name ?? "Unknown"));

    // üîπ Guardar manualmente la sesi√≥n en OWIN
    context.AuthenticationTicket = new AuthenticationTicket(identity, context.AuthenticationTicket.Properties);
    return Task.CompletedTask;
};


3Ô∏è‚É£ Revisar las Cookies para Ver si WAM Est√° Autenticando
Si OWIN sigue sin reconocer la sesi√≥n, revisemos si WAM realmente est√° creando cookies.

üìù Startup.cs - Verificar si WAM Est√° Creando Cookies
app.Use(async (context, next) =>
{
    Debug.WriteLine("üîπ Revisando Cookies de WAM...");
    foreach (var cookie in context.Request.Cookies)
    {
        Debug.WriteLine($"üç™ Cookie detectada: {cookie.Key} = {cookie.Value}");
    }
    await next.Invoke();
});

4Ô∏è‚É£ Capturar y Pasar el Token de WAM a OWIN
Si WAM ya autentic√≥ al usuario pero OWIN no lo reconoce, podemos capturar el token y pasarlo manualmente a OWIN.

üìù UseAuthenticationMiddleware - Capturar el Token de WAM
public static void UseAuthenticationMiddleware(IAppBuilder app)
{
    app.Use(async (context, next) =>
    {
        var user = HttpContext.Current.User;
        bool isAuthenticated = user?.Identity != null && user.Identity.IsAuthenticated;

        Debug.WriteLine($"‚úÖ Middleware - IsAuthenticated: {isAuthenticated}");

        // üîπ Si ya est√° autenticado en WAM pero OWIN no lo reconoce, forzamos la autenticaci√≥n
        if (isAuthenticated && !context.Authentication.User.Identity.IsAuthenticated)
        {
            Debug.WriteLine("üîπ WAM ya autentic√≥ al usuario. Forzando autenticaci√≥n en OWIN.");

            var identity = user.Identity as System.Security.Claims.ClaimsIdentity;
            if (identity != null)
            {
                context.Authentication.SignIn(new AuthenticationProperties { IsPersistent = true }, identity);
            }
        }

        await next.Invoke();
    });
}


---------------------------------------------------------------------------------------------------------

3Ô∏è‚É£ Configurar OWIN para Interceptar HRAdminPortal
üìå Ahora tenemos que hacer que OWIN escuche la respuesta de autenticaci√≥n en la URL de HRAdminPortal.

üîπ Modifica Global.asax.cs para capturar la autenticaci√≥n en HRAdminPortal

protected void Application_BeginRequest()
{
    var requestPath = HttpContext.Current.Request.Url.AbsolutePath;

    Debug.WriteLine($"üìå Verificando ruta de autenticaci√≥n: {requestPath}");

    if (requestPath.Contains("/hrpassiis/HRAdminPortal"))
    {
        Debug.WriteLine("‚úÖ Detectada URL de autenticaci√≥n de WAM, procesando login en OWIN.");
        
        HttpContext.Current.GetOwinContext().Authentication.Challenge(
            new AuthenticationProperties { RedirectUri = "/" }, 
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );
    }
}


4Ô∏è‚É£ Verificar si OWIN Recibe el Token
üìå Si OWIN no recibe el token, revisa si est√° en la cabecera HTTP.

üîπ Agrega este c√≥digo en Startup.cs para imprimir los headers HTTP:

4Ô∏è‚É£ Verificar si OWIN Recibe el Token
üìå Si OWIN no recibe el token, revisa si est√° en la cabecera HTTP.

üîπ Agrega este c√≥digo en Startup.cs para imprimir los headers HTTP:


---------------------------------------------------------------------------------------------------------









üî• Paso 3: Confirmar que OWIN Est√° Procesando Solicitudes
üìå OWIN a veces no ejecuta el middleware en ASP.NET MVC si no est√° configurado correctamente.

üîπ Modifica Startup.cs y agrega esto:

app.Use(async (context, next) =>
{
    Debug.WriteLine($"‚û° OWIN Middleware ejecutando: {context.Request.Path}");
    await next.Invoke();
});

1Ô∏è‚É£ Deshabilitar el Challenge Infinito en RedirectToIdentityProvider
Actualmente, cada vez que OWIN verifica la autenticaci√≥n y no encuentra sesi√≥n, hace un nuevo challenge. Vamos a detener ese comportamiento si ya se ha autenticado una vez.

üìù Startup.cs - Modifica RedirectToIdentityProvider

Notifications = new OpenIdConnectAuthenticationNotifications
{
    RedirectToIdentityProvider = context =>
    {
        Debug.WriteLine("üîπ OWIN: Enviando solicitud de autenticaci√≥n a WAM...");

        // üîπ Evitar redirecci√≥n infinita
        if (context.Request.Uri.AbsolutePath.Contains("/signin-oidc") && context.Request.User.Identity.IsAuthenticated)
        {
            Debug.WriteLine("‚úÖ Usuario ya autenticado, omitiendo nuevo challenge.");
            context.HandleResponse();
            return Task.CompletedTask;
        }

        return Task.CompletedTask;
    },
    MessageReceived = context =>
    {
        Debug.WriteLine("üîπ OWIN: Mensaje recibido de OIDC.");
        return Task.CompletedTask;
    },
    SecurityTokenValidated = context =>
    {
        Debug.WriteLine("‚úÖ OWIN: Token de seguridad validado.");
        return Task.CompletedTask;
    }
}

3Ô∏è‚É£ Forzar a OWIN a Leer la Sesi√≥n Desde WAM
üìå Si el usuario ya est√° autenticado con WAM pero OWIN no lo detecta, debemos hacer que OWIN lea la sesi√≥n correctamente.

üìù AutoLoginFilter.cs - Validar Si WAM Ya Autentic√≥

public override void OnActionExecuting(ActionExecutingContext filterContext)
{
    var context = HttpContext.Current;
    var user = context.User;

    Debug.WriteLine("====== USER INFO ======");
    Debug.WriteLine($"IsAuthenticated: {user?.Identity?.IsAuthenticated}");

    // üîπ Si el usuario ya tiene sesi√≥n con WAM, asegurarnos de que OWIN lo reconoce
    if (user != null && user.Identity.IsAuthenticated)
    {
        Debug.WriteLine("‚úÖ Usuario autenticado con WAM.");
        return;
    }

    Debug.WriteLine("üî¥ Usuario NO autenticado. Lanzando challenge...");

    // üîπ Evitar Challenge infinito en la misma sesi√≥n
    if (context.Session["AuthAttempt"] != null)
    {
        Debug.WriteLine("üîÑ Loop detectado. Mostrando error en lugar de redirigir.");
        filterContext.Result = new RedirectResult("/Account/LoginError");
        return;
    }

    context.Session["AuthAttempt"] = "true";

    // üîπ Lanzar Challenge
    context.GetOwinContext().Authentication.Challenge(
        new AuthenticationProperties { RedirectUri = context.Request.Url.ToString() },
        OpenIdConnectAuthenticationDefaults.AuthenticationType
    );

    filterContext.Result = new HttpUnauthorizedResult();
}


4Ô∏è‚É£ Forzar WAM a Pasar el Token Correctamente
üìå Si WAM no est√° pasando el token correctamente, debemos asegurarnos de que se env√≠a en la cabecera HTTP.

üìù Startup.cs - Forzar a WAM a Pasar el Token

app.Use(async (context, next) =>
{
    if (context.Request.Headers.ContainsKey("Authorization"))
    {
        Debug.WriteLine("üîπ Token de WAM detectado en la cabecera.");
    }
    else
    {
        Debug.WriteLine("‚ö†Ô∏è No hay token de WAM en la cabecera.");
    }

    await next.Invoke();
});














using System.Diagnostics;
using System.Security.Claims;
using System.Web;
using System.Web.Mvc;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.OpenIdConnect;

namespace MyMvcApp.Filters
{
    public class AutoLoginFilter : ActionFilterAttribute
    {
        public override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            var context = HttpContext.Current;
            var user = context.User;
            var requestPath = context.Request.Path;

            Debug.WriteLine("====== USER INFO ======");
            Debug.WriteLine($"IsAuthenticated: {user?.Identity?.IsAuthenticated}");
            Debug.WriteLine($"Current URL: {context.Request.Url}");

            // üîπ Evita redirigir si estamos en el callback de autenticaci√≥n
            if (requestPath.StartsWith("/signin-oidc", System.StringComparison.OrdinalIgnoreCase))
            {
                Debug.WriteLine("üü¢ Callback de OIDC detectado. No redirigir.");
                return;
            }

            // üîπ Si el usuario ya est√° autenticado, no hacemos nada
            if (user != null && user.Identity.IsAuthenticated)
            {
                Debug.WriteLine("‚úÖ Usuario autenticado. Continuando...");
                return;
            }

            Debug.WriteLine("üî¥ Usuario no autenticado.");

            // üîπ Si ya intent√≥ autenticarse y sigue sin √©xito, evitar loop
            if (context.Session["AuthAttempt"] != null)
            {
                Debug.WriteLine("üîÑ Se detect√≥ un loop de autenticaci√≥n. Mostrando error.");
                filterContext.Result = new RedirectResult("/Account/LoginError");
                return;
            }

            // üîπ Guardar en sesi√≥n que estamos intentando autenticarnos
            context.Session["AuthAttempt"] = "true";

            // üîπ Redirigir al login
            Debug.WriteLine("üîπ Redirigiendo a login...");
            context.GetOwinContext().Authentication.Challenge(
                new AuthenticationProperties { RedirectUri = context.Request.Url.ToString() },
                OpenIdConnectAuthenticationDefaults.AuthenticationType
            );

            filterContext.Result = new HttpUnauthorizedResult();
        }
    }
}



app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
    ExpireTimeSpan = System.TimeSpan.FromMinutes(60),
    SlidingExpiration = true,
    CookieHttpOnly = true,
    CookieSecure = CookieSecureOption.Always,
    CookieSameSite = SameSiteMode.Lax
});


public override void OnActionExecuting(ActionExecutingContext filterContext)
{
    var requestPath = HttpContext.Current.Request.Path;

    // No ejecutar autenticaci√≥n en la p√°gina de retorno de OIDC
    if (requestPath.StartsWith("/signin-oidc", System.StringComparison.OrdinalIgnoreCase))
    {
        return;
    }

    var user = HttpContext.Current.User;

    Debug.WriteLine($"IsAuthenticated: {user?.Identity?.IsAuthenticated}");
    
    if (user == null || !user.Identity.IsAuthenticated)
    {
        Debug.WriteLine("üî¥ Usuario no autenticado. Redirigiendo a login...");
        
        HttpContext.Current.GetOwinContext().Authentication.Challenge(
            new AuthenticationProperties { RedirectUri = HttpContext.Current.Request.Url.ToString() },
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );

        filterContext.Result = new HttpUnauthorizedResult();
    }
}



using System.Diagnostics;
using System.Security.Claims;
using System.Web;
using System.Web.Mvc;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.OpenIdConnect;

namespace MyMvcApp.Filters
{
    public class AutoLoginFilter : ActionFilterAttribute
    {
        public override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            var user = HttpContext.Current.User;

            // üîπ Ver informaci√≥n del usuario en la consola de Debug
            Debug.WriteLine("====== USER INFO ======");
            if (user != null)
            {
                Debug.WriteLine($"IsAuthenticated: {user.Identity.IsAuthenticated}");
                Debug.WriteLine($"Authentication Type: {user.Identity.AuthenticationType}");
                Debug.WriteLine($"Name: {user.Identity.Name}");

                var claimsIdentity = user.Identity as ClaimsIdentity;
                if (claimsIdentity != null)
                {
                    foreach (var claim in claimsIdentity.Claims)
                    {
                        Debug.WriteLine($"Claim: {claim.Type} - {claim.Value}");
                    }
                }
            }
            else
            {
                Debug.WriteLine("User is NULL!");
            }
            Debug.WriteLine("======================");

            // üîπ Si el usuario no est√° autenticado, redirigir al login
            if (user == null || !user.Identity.IsAuthenticated)
            {
                Debug.WriteLine("üî¥ Usuario no autenticado. Redirigiendo a login...");

                HttpContext.Current.GetOwinContext().Authentication.Challenge(
                    new AuthenticationProperties { RedirectUri = HttpContext.Current.Request.Url.ToString() },
                    OpenIdConnectAuthenticationDefaults.AuthenticationType
                );

                filterContext.Result = new HttpUnauthorizedResult();
            }
        }
    }
}




using Microsoft.Owin;
using Owin;
using Microsoft.Owin.Security.Cookies;
using Microsoft.Owin.Security.OpenIdConnect;
using Microsoft.IdentityModel.Tokens;
using System.Threading.Tasks;
using System.Configuration;
using System.Web.Helpers;

[assembly: OwinStartup(typeof(MyMvcApp.Startup))]

namespace MyMvcApp
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // üîπ 1. Configurar autenticaci√≥n basada en cookies
            app.UseCookieAuthentication(new CookieAuthenticationOptions
            {
                AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
                ExpireTimeSpan = System.TimeSpan.FromMinutes(60),
                SlidingExpiration = true
            });

            // üîπ 2. Configurar OpenID Connect para autenticaci√≥n autom√°tica
            app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
            {
                ClientId = ConfigurationManager.AppSettings["OIDC:ClientId"],
                Authority = ConfigurationManager.AppSettings["OIDC:Authority"],
                RedirectUri = ConfigurationManager.AppSettings["OIDC:RedirectUri"],
                ResponseType = "id_token",
                Scope = "openid profile email",
                SaveTokens = true,

                TokenValidationParameters = new TokenValidationParameters
                {
                    ValidateIssuer = true,
                    ValidateAudience = true,
                    ValidateLifetime = true,
                    ValidAudience = ConfigurationManager.AppSettings["OIDC:ClientId"]
                },

                Notifications = new OpenIdConnectAuthenticationNotifications
                {
                    AuthenticationFailed = context =>
                    {
                        context.HandleResponse();
                        context.Response.Redirect("/Error?message=" + context.Exception.Message);
                        return Task.FromResult(0);
                    }
                }
            });

            // üîπ 3. Evitar problemas con antiforgery tokens en OWIN
            AntiForgeryConfig.UniqueClaimTypeIdentifier = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier";
        }
    }
}

using System.Web;
using System.Web.Mvc;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.OpenIdConnect;

namespace MyMvcApp.Filters
{
    public class AutoLoginFilter : ActionFilterAttribute
    {
        public override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            var user = HttpContext.Current.User;
            
            if (user == null || !user.Identity.IsAuthenticated)
            {
                // üîπ Redirigir autom√°ticamente al login si el usuario no est√° autenticado
                HttpContext.Current.GetOwinContext().Authentication.Challenge(
                    new AuthenticationProperties { RedirectUri = HttpContext.Current.Request.Url.ToString() },
                    OpenIdConnectAuthenticationDefaults.AuthenticationType
                );

                // üîπ Detener la ejecuci√≥n de la acci√≥n actual
                filterContext.Result = new HttpUnauthorizedResult();
            }
        }
    }
}

using System.Web.Mvc;
using MyMvcApp.Filters;

namespace MyMvcApp.Controllers
{
    [AutoLoginFilter]  // ‚úÖ Aplica el filtro de autenticaci√≥n autom√°tica
    public class HomeController : Controller
    {
        public ActionResult Index()
        {
            return View();
        }
    }
}















app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = AuthProperties.ClientId,
    ClientSecret = AuthProperties.ClientSecret,
    Authority = AuthProperties.BaseUrl,
    RedirectUri = AuthProperties.RedirectUri,
    CookieManager = new SystemWebCookieManager(),
    SaveTokens = true, // <--- Guarda los tokens en la sesi√≥n de autenticaci√≥n
    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        AuthenticationFailed = OnAuthenticationFailed,
        SecurityTokenValidated = OnSecurityTokenValidated
    }
});

private static async Task OnSecurityTokenValidated(SecurityTokenValidatedNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions> context)
{
    var identity = context.AuthenticationTicket.Identity;
    
    // Puedes agregar claims personalizados si es necesario
    identity.AddClaim(new System.Security.Claims.Claim("id_token", context.ProtocolMessage.IdToken));

    context.AuthenticationTicket = new AuthenticationTicket(identity, context.AuthenticationTicket.Properties);
}


app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
    LoginPath = new PathString("/Account/Login"),
    ExpireTimeSpan = TimeSpan.FromMinutes(60),
    SlidingExpiration = true,
    CookieSameSite = SameSiteMode.Lax, // Ajusta esto si hay problemas con cookies en navegadores modernos
    CookieHttpOnly = true,
    CookieSecure = CookieSecureOption.Always
});


public static void UseAuthenticationMiddleware(IAppBuilder app)
{
    app.Use(async (context, next) =>
    {
        var owinContext = context.Get<IOwinContext>();
        var user = owinContext.Authentication.User;
        bool isAuthenticated = user?.Identity != null && user.Identity.IsAuthenticated;

        if (!isAuthenticated)
        {
            // Solo desaf√≠a si no estamos ya en un intento de autenticaci√≥n
            if (!context.Request.Path.Value.Contains("/signin-oidc"))
            {
                owinContext.Authentication.Challenge(
                    new AuthenticationProperties { RedirectUri = AuthProperties.RedirectUri },
                    OpenIdConnectAuthenticationDefaults.AuthenticationType
                );

                context.Response.StatusCode = 401;
                return;
            }
        }

        await next();
    });
}









public static class AuthConfig
{
    public static void ConfigureAuth(IAppBuilder app, string clientId, string clientSecret, string baseUrl, string redirectUri)
    {
        AuthProperties.ClientId = clientId;
        AuthProperties.ClientSecret = clientSecret;
        AuthProperties.BaseUrl = baseUrl;
        AuthProperties.RedirectUri = redirectUri;

        app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
            CookieSameSite = SameSiteMode.None
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = AuthProperties.ClientId,
            ClientSecret = AuthProperties.ClientSecret,
            Authority = AuthProperties.BaseUrl,
            RedirectUri = AuthProperties.RedirectUri,
            ResponseType = OpenIdConnectResponseType.CodeIdToken,
            SignInAsAuthenticationType = CookieAuthenticationDefaults.AuthenticationType
        });
    }

    public static void UseAuthenticationMiddleware(IAppBuilder app)
    {
        app.Use(async (context, next) =>
        {
            if (!context.Authentication.User.Identity.IsAuthenticated)
            {
                string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

                context.Authentication.Challenge(new AuthenticationProperties
                {
                    RedirectUri = redirectUri
                }, OpenIdConnectAuthenticationDefaults.AuthenticationType);

                context.Response.StatusCode = 401;
                return;
            }

            await next();
        });
    }
}



public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
            CookieSameSite = SameSiteMode.None
        });

        app.Use(async (context, next) =>
        {
            if (!context.Authentication.User.Identity.IsAuthenticated)
            {
                string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

                context.Authentication.Challenge(new AuthenticationProperties
                {
                    RedirectUri = redirectUri
                }, OpenIdConnectAuthenticationDefaults.AuthenticationType);

                context.Response.StatusCode = 401;
                return;
            }

            await next();
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = "tu-client-id",
            Authority = "https://tu-idp.com",
            RedirectUri = "https://tuapp.com/signin-oidc",
            ResponseType = "code id_token",
            UseTokenLifetime = true,
            SignInAsAuthenticationType = CookieAuthenticationDefaults.AuthenticationType
        });
    }
}



protected void Application_BeginRequest(object sender, EventArgs e)
{
    try
    {
        if (!(HttpContext.Current.User?.Identity?.IsAuthenticated ?? false)) // Verifica autenticaci√≥n correctamente
        {
            string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

            // Redirigir manualmente a WAM sin usar OWIN
            HttpContext.Current.Response.Clear();
            HttpContext.Current.Response.Redirect(redirectUri, true);
            HttpContext.Current.ApplicationInstance.CompleteRequest();
        }
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException("Error en la redirecci√≥n a WAM: " + ex.Message);
    }
}


protected void Application_PostAuthenticateRequest(object sender, EventArgs e)
{
    var owinContext = HttpContext.Current.GetOwinContext();
    if (owinContext.Authentication.User != null && owinContext.Authentication.User.Identity.IsAuthenticated)
    {
        HttpContext.Current.User = owinContext.Authentication.User;
    }
}

protected void Application_BeginRequest(object sender, EventArgs e)
{
    if (!HttpContext.Current.User?.Identity?.IsAuthenticated ?? true)
    {
        // NO reemplazar HttpContext.User aqu√≠, solo redirigir si es necesario
        AuthHelper.RedirectToWAM();
    }
}


protected void Application_BeginRequest(object sender, EventArgs e)
{
    if (!HttpContext.Current.User.Identity.IsAuthenticated)
    {
        AuthHelper.RedirectToWAM(); // Llama a tu m√©todo que redirige a WAM
    }
}

public class RequireAuthenticationFilter : AuthorizeAttribute
{
    protected override void HandleUnauthorizedRequest(AuthorizationContext filterContext)
    {
        if (!filterContext.HttpContext.User.Identity.IsAuthenticated)
        {
            AuthHelper.RedirectToWAM(); // Redirige a WAM si el usuario no est√° autenticado
        }
        else
        {
            base.HandleUnauthorizedRequest(filterContext);
        }
    }
}

public class FilterConfig
{
    public static void RegisterGlobalFilters(GlobalFilterCollection filters)
    {
        filters.Add(new RequireAuthenticationFilter()); // Aplica autenticaci√≥n a toda la app
        filters.Add(new HandleErrorAttribute());
    }
}

public static void RedirectToWAM()
{
    try
    {
        string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

        HttpContext.Current.Response.Clear();
        HttpContext.Current.Response.Redirect(redirectUri, true);
        HttpContext.Current.ApplicationInstance.CompleteRequest();
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException("Error en la redirecci√≥n a WAM: " + ex.Message);
    }
}
