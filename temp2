using System;
using System.IO;
using System.Text;

class Program
{
    static void Main()
    {
        string filePath = "mensaje.pgp"; // Ruta del archivo con el mensaje PGP encriptado
        string encryptedText = File.ReadAllText(filePath);

        // Convertir el texto en un formato adecuado para appsettings.json
        string jsonSafeText = ConvertToJsonSafe(encryptedText);
        string base64Text = ConvertToBase64(encryptedText);

        Console.WriteLine("Texto JSON Safe:\n" + jsonSafeText);
        Console.WriteLine("\nTexto Base64:\n" + base64Text);
    }

    static string ConvertToJsonSafe(string input)
    {
        return input.Replace("\r", "").Replace("\n", "\\n"); // Reemplaza saltos de línea para JSON
    }

    static string ConvertToBase64(string input)
    {
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(input)); // Convierte a Base64
    }
}


public class CryptoManager
{
    private readonly IWCMService _wcmService;
    private readonly IPGPEncryptionService _pgpEncryptionService;

    public CryptoManager(IWCMService wcmService, IPGPEncryptionService pgpEncryptionService)
    {
        _wcmService = wcmService ?? throw new ArgumentNullException(nameof(wcmService));
        _pgpEncryptionService = pgpEncryptionService ?? throw new ArgumentNullException(nameof(pgpEncryptionService));
    }

    public async Task<string> DecryptTextAsync(string encryptedText)
    {
        if (string.IsNullOrWhiteSpace(encryptedText))
            throw new ArgumentException("El texto encriptado no puede estar vacío.", nameof(encryptedText));

        // Leer credenciales
        string passphrase = _wcmService.ReadCredential("passphrase");
        string privateKey = _wcmService.ReadCredential("privateKey");

        if (string.IsNullOrWhiteSpace(passphrase) || string.IsNullOrWhiteSpace(privateKey))
            throw new InvalidOperationException("No se encontraron las credenciales necesarias para desencriptar.");

        // Desencriptar
        return await _pgpEncryptionService.DecryptText(encryptedText, privateKey, passphrase);
    }
}



public static class ValidationHelper
{
    public static void ValidateNotNullOrWhiteSpace(string value, string paramName, string errorMessage = null)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException(errorMessage ?? $"{paramName} cannot be empty or null.", paramName);
        }
    }
}


public static void CreateCredential(string name, string userName, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("The credential name cannot be empty or null.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("Username cannot be empty or null.", nameof(userName));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("The secret cannot be empty or null.", nameof(secret));
    }

    try
    {
        if (secret.Length > MAX_SECRET_LENGTH)
        {
            Console.WriteLine($"The secret exceeds {MAX_SECRET_LENGTH} characters. Splitting into fragments...");
            var credentialFragments = BuildPartitionedLongCredential(name, secret);

            foreach (var entry in credentialFragments)
            {
                WriteCredentialSafely(entry.Key, userName, entry.Value);
            }
        }
        else
        {
            WriteCredentialSafely(name, userName, secret);
        }
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error creating credential '{name}': {ex.Message}");
    }
}

private static void WriteCredentialSafely(string name, string userName, string secret)
{
    try
    {
        CredentialManager.WriteCredential(
            applicationName: name,
            userName: userName,
            secret: secret,
            persistence: CredentialPersistence.LocalMachine
        );

        Console.WriteLine($"Credential '{name}' created successfully.");
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Failed to create credential '{name}': {ex.Message}");
    }
}


public static Dictionary<string, string> BuildPartitionedLongCredential(string name, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("El secreto no puede estar vacío o ser nulo.", nameof(secret));
    }

    var partitions = new Dictionary<string, string>();
    int totalFragments = (int)Math.Ceiling((double)secret.Length / MAX_SECRET_LENGTH);

    for (int i = 0; i < totalFragments; i++)
    {
        string fragment = secret.Substring(i * MAX_SECRET_LENGTH, Math.Min(MAX_SECRET_LENGTH, secret.Length - i * MAX_SECRET_LENGTH));
        string fragmentName = $"{name}_part{i}";
        partitions[fragmentName] = fragment;
    }

    return partitions;
}

public static void CreateCredentialFromFile(string name, string userName, string filePath)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vacío o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrWhiteSpace(filePath))
    {
        throw new ArgumentException("La ruta del archivo no puede estar vacía o ser nula.", nameof(filePath));
    }

    if (!File.Exists(filePath))
    {
        throw new FileNotFoundException($"El archivo especificado no existe: {filePath}");
    }

    string secret;
    try
    {
        secret = File.ReadAllText(filePath);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
        throw;
    }

    if (string.IsNullOrEmpty(secret))
    {
        Console.Error.WriteLine("El archivo está vacío. No se crearán credenciales.");
        return;
    }

    var credentialFragments = BuildPartitionedLongCredential(name, secret);

    foreach (var entry in credentialFragments)
    {
        CreateCredential(entry.Key, userName, entry.Value);
    }
}


public static string ReadCredential(string name)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    try
    {
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(name))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        if (credentials.Count == 0)
        {
            throw new InvalidOperationException($"No se encontraron credenciales para el nombre: {name}");
        }

        return string.Concat(credentials.Select(c => c.Password));
    }
    catch (Exception ex)
    {
        // Loggear el error (puedes implementar un sistema de logging como Serilog)
        Console.Error.WriteLine($"Error al leer credenciales: {ex.Message}");
        throw;
    }
}

public static void CreateCredentialFromFile(string name, string userName, string filePath)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vacío o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrWhiteSpace(filePath))
    {
        throw new ArgumentException("La ruta del archivo no puede estar vacía o ser nula.", nameof(filePath));
    }

    if (!File.Exists(filePath))
    {
        throw new FileNotFoundException($"El archivo especificado no existe: {filePath}");
    }

    string secret;
    try
    {
        secret = File.ReadAllText(filePath);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
        throw;
    }

    if (string.IsNullOrEmpty(secret))
    {
        Console.Error.WriteLine("El archivo está vacío. No se crearán credenciales.");
        return;
    }

    int totalFragments = (int)Math.Ceiling((double)secret.Length / MAX_SECRET_LENGTH);

    for (int i = 0; i < totalFragments; i++)
    {
        string fragment = secret.Substring(i * MAX_SECRET_LENGTH, Math.Min(MAX_SECRET_LENGTH, secret.Length - i * MAX_SECRET_LENGTH));
        string fragmentName = $"{name}_part{i}";

        CreateCredential(fragmentName, userName, fragment);
    }
}


public static void CreateCredential(string name, string userName, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vacío o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("El secreto no puede estar vacío o ser nulo.", nameof(secret));
    }

    if (secret.Length > MAX_SECRET_LENGTH)
    {
        throw new ArgumentException($"El secreto excede el tamaño máximo permitido de {MAX_SECRET_LENGTH} caracteres.");
    }

    try
    {
        CredentialManager.WriteCredential(
            applicationName: name,
            userName: userName,
            secret: secret,
            persistence: CredentialPersistence.LocalMachine
        );
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al crear la credencial: {ex.Message}");
        throw;
    }
}



using System;
using System.Linq;
using Meziantou.Framework.Win32;

class Program
{
    static void Main()
    {
        string appName = "MyApp";
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(appName))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        string fullKey = string.Concat(credentials.Select(c => c.Secret));
        
        Console.WriteLine("Clave reconstruida:\n" + fullKey);
    }
}


using Meziantou.Framework.Win32;
using System;
using System.Text;

public class CredentialManagerHelper
{
    public static void SaveKeyInFragments(string applicationName, string key, int fragmentSize = 2000)
    {
        int totalFragments = (int)Math.Ceiling((double)key.Length / fragmentSize);

        for (int i = 0; i < totalFragments; i++)
        {
            string fragment = key.Substring(i * fragmentSize, Math.Min(fragmentSize, key.Length - i * fragmentSize));
            string fragmentName = $"{applicationName}_Part{i}";

            CredentialManager.WriteCredential(
                applicationName: fragmentName,
                userName: "fragment",
                secret: fragment,
                comment: $"Part {i + 1} of {totalFragments}",
                persistence: CredentialPersistence.LocalMachine);
        }
    }
}

public class CredentialManagerHelper
{
    public static string RetrieveKeyFromFragments(string applicationName)
    {
        StringBuilder keyBuilder = new StringBuilder();
        int partIndex = 0;

        while (true)
        {
            string fragmentName = $"{applicationName}_Part{partIndex}";
            var credential = CredentialManager.ReadCredential(fragmentName);

            if (credential == null) break; // Termina si no encuentra más fragmentos

            keyBuilder.Append(credential.Password);
            partIndex++;
        }

        return keyBuilder.ToString();
    }
}


using System;
using System.IO;
using PgpCore;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.Write("Ingrese el texto a encriptar: ");
        string inputText = Console.ReadLine();
        
        string publicKey = GetPublicKeyFromWCM();
        string privateKey = GetPrivateKeyFromWCM();
        string passphrase = "TuPassphrase"; // Opcional si la clave privada tiene una contraseña
        
        string encryptedText = await EncryptText(inputText, publicKey);
        Console.WriteLine("Texto Encriptado:\n" + encryptedText);
        
        string decryptedText = await DecryptText(encryptedText, privateKey, passphrase);
        Console.WriteLine("Texto Desencriptado:\n" + decryptedText);
    }

    static string GetPublicKeyFromWCM()
    {
        // Aquí iría la lógica para obtener la clave pública desde el Windows Credential Manager
        return "ClavePúblicaFalsa";
    }

    static string GetPrivateKeyFromWCM()
    {
        // Aquí iría la lógica para obtener la clave privada desde el Windows Credential Manager
        return "ClavePrivadaFalsa";
    }

    static async Task<string> EncryptText(string text, string publicKey)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(text)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(publicKey)))
        {
            await pgp.EncryptStreamAsync(inputStream, outputStream, keyStream);
            return Convert.ToBase64String(outputStream.ToArray());
        }
    }

    static async Task<string> DecryptText(string encryptedText, string privateKey, string passphrase)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(Convert.FromBase64String(encryptedText)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(privateKey)))
        {
            await pgp.DecryptStreamAsync(inputStream, outputStream, keyStream, passphrase);
            return System.Text.Encoding.UTF8.GetString(outputStream.ToArray());
        }
    }
}
