public static string ReadCredential(string name)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    try
    {
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(name))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        if (credentials.Count == 0)
        {
            throw new InvalidOperationException($"No se encontraron credenciales para el nombre: {name}");
        }

        return string.Concat(credentials.Select(c => c.Password));
    }
    catch (Exception ex)
    {
        // Loggear el error (puedes implementar un sistema de logging como Serilog)
        Console.Error.WriteLine($"Error al leer credenciales: {ex.Message}");
        throw;
    }
}

public static void CreateCredentialFromFile(string name, string userName, string filePath)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vacío o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrWhiteSpace(filePath))
    {
        throw new ArgumentException("La ruta del archivo no puede estar vacía o ser nula.", nameof(filePath));
    }

    if (!File.Exists(filePath))
    {
        throw new FileNotFoundException($"El archivo especificado no existe: {filePath}");
    }

    string secret;
    try
    {
        secret = File.ReadAllText(filePath);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
        throw;
    }

    if (string.IsNullOrEmpty(secret))
    {
        Console.Error.WriteLine("El archivo está vacío. No se crearán credenciales.");
        return;
    }

    int totalFragments = (int)Math.Ceiling((double)secret.Length / MAX_SECRET_LENGTH);

    for (int i = 0; i < totalFragments; i++)
    {
        string fragment = secret.Substring(i * MAX_SECRET_LENGTH, Math.Min(MAX_SECRET_LENGTH, secret.Length - i * MAX_SECRET_LENGTH));
        string fragmentName = $"{name}_part{i}";

        CreateCredential(fragmentName, userName, fragment);
    }
}


public static void CreateCredential(string name, string userName, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vacío o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vacío o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("El secreto no puede estar vacío o ser nulo.", nameof(secret));
    }

    if (secret.Length > MAX_SECRET_LENGTH)
    {
        throw new ArgumentException($"El secreto excede el tamaño máximo permitido de {MAX_SECRET_LENGTH} caracteres.");
    }

    try
    {
        CredentialManager.WriteCredential(
            applicationName: name,
            userName: userName,
            secret: secret,
            persistence: CredentialPersistence.LocalMachine
        );
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al crear la credencial: {ex.Message}");
        throw;
    }
}



using System;
using System.Linq;
using Meziantou.Framework.Win32;

class Program
{
    static void Main()
    {
        string appName = "MyApp";
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(appName))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        string fullKey = string.Concat(credentials.Select(c => c.Secret));
        
        Console.WriteLine("Clave reconstruida:\n" + fullKey);
    }
}


using Meziantou.Framework.Win32;
using System;
using System.Text;

public class CredentialManagerHelper
{
    public static void SaveKeyInFragments(string applicationName, string key, int fragmentSize = 2000)
    {
        int totalFragments = (int)Math.Ceiling((double)key.Length / fragmentSize);

        for (int i = 0; i < totalFragments; i++)
        {
            string fragment = key.Substring(i * fragmentSize, Math.Min(fragmentSize, key.Length - i * fragmentSize));
            string fragmentName = $"{applicationName}_Part{i}";

            CredentialManager.WriteCredential(
                applicationName: fragmentName,
                userName: "fragment",
                secret: fragment,
                comment: $"Part {i + 1} of {totalFragments}",
                persistence: CredentialPersistence.LocalMachine);
        }
    }
}

public class CredentialManagerHelper
{
    public static string RetrieveKeyFromFragments(string applicationName)
    {
        StringBuilder keyBuilder = new StringBuilder();
        int partIndex = 0;

        while (true)
        {
            string fragmentName = $"{applicationName}_Part{partIndex}";
            var credential = CredentialManager.ReadCredential(fragmentName);

            if (credential == null) break; // Termina si no encuentra más fragmentos

            keyBuilder.Append(credential.Password);
            partIndex++;
        }

        return keyBuilder.ToString();
    }
}


using System;
using System.IO;
using PgpCore;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.Write("Ingrese el texto a encriptar: ");
        string inputText = Console.ReadLine();
        
        string publicKey = GetPublicKeyFromWCM();
        string privateKey = GetPrivateKeyFromWCM();
        string passphrase = "TuPassphrase"; // Opcional si la clave privada tiene una contraseña
        
        string encryptedText = await EncryptText(inputText, publicKey);
        Console.WriteLine("Texto Encriptado:\n" + encryptedText);
        
        string decryptedText = await DecryptText(encryptedText, privateKey, passphrase);
        Console.WriteLine("Texto Desencriptado:\n" + decryptedText);
    }

    static string GetPublicKeyFromWCM()
    {
        // Aquí iría la lógica para obtener la clave pública desde el Windows Credential Manager
        return "ClavePúblicaFalsa";
    }

    static string GetPrivateKeyFromWCM()
    {
        // Aquí iría la lógica para obtener la clave privada desde el Windows Credential Manager
        return "ClavePrivadaFalsa";
    }

    static async Task<string> EncryptText(string text, string publicKey)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(text)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(publicKey)))
        {
            await pgp.EncryptStreamAsync(inputStream, outputStream, keyStream);
            return Convert.ToBase64String(outputStream.ToArray());
        }
    }

    static async Task<string> DecryptText(string encryptedText, string privateKey, string passphrase)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(Convert.FromBase64String(encryptedText)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(privateKey)))
        {
            await pgp.DecryptStreamAsync(inputStream, outputStream, keyStream, passphrase);
            return System.Text.Encoding.UTF8.GetString(outputStream.ToArray());
        }
    }
}
