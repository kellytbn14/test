public static Command ReadCredentialCommand()
{
    var appName = new Argument<string>("appName", "Credential Name");

    var partitionedOption = new Option<bool>("-p", "Read partitioned credential");

    var command = new Command("read-credential", "Read WCM credential")
    {
        partitionedOption,
        appName
    };

    command.SetHandler((bool isPartitioned, string name) =>
    {
        CommandHandlers.ReadCredentialFromWCM(name, isPartitioned);
    }, partitionedOption, appName);

    return command;
}


command.SetHandler((string name) =>
{
    CommandHandlers.ReadCredentialFromWCM(name, false);
}, appName);


using System;
using System.CommandLine;

public static Command BuildCreateCredentialCommand()
{
    var appName = new Argument<string>("appName", "Credential Name");
    var userName = new Argument<string>("userName", "User name");

    var command = new Command("create-credential", "Create a credential in WCM")
    {
        appName,
        userName
    };

    command.SetHandler((string app, string user) =>
    {
        Console.Write("üîí Enter Secret Password: ");
        string secret = ReadPassword();

        Console.WriteLine("\n‚úÖ Credential received. Processing...");
        CommandHandlers.CreateCredentialOnWCM(app, user, secret);
    }, appName, userName);

    return command;
}

// Funci√≥n para leer la contrase√±a sin mostrar caracteres en la consola
private static string ReadPassword()
{
    string password = "";
    ConsoleKeyInfo key;

    do
    {
        key = Console.ReadKey(true);

        if (key.Key == ConsoleKey.Enter)
            break;

        if (key.Key == ConsoleKey.Backspace && password.Length > 0)
        {
            password = password[..^1];
            Console.Write("\b \b"); // Borra el √∫ltimo car√°cter en pantalla
        }
        else if (!char.IsControl(key.KeyChar))
        {
            password += key.KeyChar;
            Console.Write("*"); // Muestra asteriscos en lugar de caracteres reales
        }

    } while (true);

    return password;
}


using System;
using System.CommandLine;
using System.CommandLine.NamingConventionBinder;
using System.Threading.Tasks;

class Program
{
    static async Task<int> Main(string[] args)
    {
        var rootCommand = BuildRootCommand();
        return await rootCommand.InvokeAsync(args);
    }

    private static RootCommand BuildRootCommand()
    {
        var rootCommand = new RootCommand("Aplicaci√≥n CLI para encriptar y desencriptar");

        rootCommand.AddCommand(BuildEncryptCommand());
        rootCommand.AddCommand(BuildDecryptCommand());

        return rootCommand;
    }

    private static Command BuildEncryptCommand()
    {
        var nameVarArgument = new Argument<string>("namevar", "Nombre de la variable");
        var textArgument = new Argument<string>("texto", "Texto a encriptar");

        var encryptCommand = new Command("encrypt", "Encripta un texto")
        {
            nameVarArgument,
            textArgument
        };

        encryptCommand.Handler = CommandHandler.Create<string, string>(CommandHandlers.Encrypt);

        return encryptCommand;
    }

    private static Command BuildDecryptCommand()
    {
        var nameVarArgument = new Argument<string>("namevar", "Nombre de la variable");

        var decryptCommand = new Command("decrypt", "Desencripta un texto")
        {
            nameVarArgument
        };

        decryptCommand.Handler = CommandHandler.Create<string>(CommandHandlers.Decrypt);

        return decryptCommand;
    }
}

static class CommandHandlers
{
    public static void Encrypt(string namevar, string texto)
    {
        Console.WriteLine($"üîí Encriptando '{texto}' con la variable '{namevar}'...");
        // Aqu√≠ puedes agregar la l√≥gica real de encriptaci√≥n.
    }

    public static void Decrypt(string namevar)
    {
        Console.WriteLine($"üîì Desencriptando con la variable '{namevar}'...");
        // Aqu√≠ puedes agregar la l√≥gica real de desencriptaci√≥n.
    }
}


using System;
using System.CommandLine;
using System.Threading.Tasks;

class Program
{
    static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("Aplicaci√≥n CLI para encriptar y desencriptar");

        // Definir argumentos expl√≠citos
        var nameVarArgument = new Argument<string>("namevar", "Nombre de la variable");
        var textArgument = new Argument<string>("texto", "Texto a encriptar");

        var encryptCommand = new Command("encrypt", "Encripta un texto")
        {
            nameVarArgument,
            textArgument
        };

        var decryptCommand = new Command("decrypt", "Desencripta un texto")
        {
            nameVarArgument
        };

        // Asignar manejadores correctamente
        encryptCommand.SetHandler((string namevar, string texto) =>
        {
            Console.WriteLine($"üîí Encriptando '{texto}' con la variable '{namevar}'...");
            // L√≥gica de encriptaci√≥n aqu√≠
        }, nameVarArgument, textArgument);

        decryptCommand.SetHandler((string namevar) =>
        {
            Console.WriteLine($"üîì Desencriptando usando '{namevar}'...");
            // L√≥gica de desencriptaci√≥n aqu√≠
        }, nameVarArgument);

        rootCommand.AddCommand(encryptCommand);
        rootCommand.AddCommand(decryptCommand);

        return await rootCommand.InvokeAsync(args);
    }
}


using System;
using System.CommandLine;
using System.Threading.Tasks;

class Program
{
    static async Task<int> Main(string[] args)
    {
        // Crear comandos
        var rootCommand = new RootCommand("Aplicaci√≥n CLI para encriptar y desencriptar");

        var encryptCommand = new Command("encrypt", "Encripta un texto")
        {
            new Argument<string>("namevar", "Nombre de la variable"),
            new Argument<string>("texto", "Texto a encriptar")
        };

        var decryptCommand = new Command("decrypt", "Desencripta un texto")
        {
            new Argument<string>("namevar", "Nombre de la variable")
        };

        // Asignar manejadores de comandos con SetHandler()
        encryptCommand.SetHandler((namevar, texto) =>
        {
            Console.WriteLine($"üîí Encriptando '{texto}' con la variable '{namevar}'...");
            // Aqu√≠ ir√≠a la l√≥gica de encriptaci√≥n
        }, 
        encryptCommand.Arguments[0], encryptCommand.Arguments[1]);

        decryptCommand.SetHandler((namevar) =>
        {
            Console.WriteLine($"üîì Desencriptando usando '{namevar}'...");
            // Aqu√≠ ir√≠a la l√≥gica de desencriptaci√≥n
        }, 
        decryptCommand.Arguments[0]);

        rootCommand.AddCommand(encryptCommand);
        rootCommand.AddCommand(decryptCommand);

        // Ejecutar el parser de argumentos
        return await rootCommand.InvokeAsync(args);
    }
}


string base64Text = Convert.ToBase64String(Encoding.UTF8.GetBytes(pgpEncryptedText));

string pgpEncryptedText = Encoding.UTF8.GetString(Convert.FromBase64String(base64Text));


using System;
using System.IO;
using System.Text;

class Program
{
    static void Main()
    {
        string filePath = "mensaje.pgp"; // Ruta del archivo con el mensaje PGP encriptado
        string encryptedText = File.ReadAllText(filePath);

        // Convertir el texto en un formato adecuado para appsettings.json
        string jsonSafeText = ConvertToJsonSafe(encryptedText);
        string base64Text = ConvertToBase64(encryptedText);

        Console.WriteLine("Texto JSON Safe:\n" + jsonSafeText);
        Console.WriteLine("\nTexto Base64:\n" + base64Text);
    }

    static string ConvertToJsonSafe(string input)
    {
        return input.Replace("\r", "").Replace("\n", "\\n"); // Reemplaza saltos de l√≠nea para JSON
    }

    static string ConvertToBase64(string input)
    {
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(input)); // Convierte a Base64
    }
}


public class CryptoManager
{
    private readonly IWCMService _wcmService;
    private readonly IPGPEncryptionService _pgpEncryptionService;

    public CryptoManager(IWCMService wcmService, IPGPEncryptionService pgpEncryptionService)
    {
        _wcmService = wcmService ?? throw new ArgumentNullException(nameof(wcmService));
        _pgpEncryptionService = pgpEncryptionService ?? throw new ArgumentNullException(nameof(pgpEncryptionService));
    }

    public async Task<string> DecryptTextAsync(string encryptedText)
    {
        if (string.IsNullOrWhiteSpace(encryptedText))
            throw new ArgumentException("El texto encriptado no puede estar vac√≠o.", nameof(encryptedText));

        // Leer credenciales
        string passphrase = _wcmService.ReadCredential("passphrase");
        string privateKey = _wcmService.ReadCredential("privateKey");

        if (string.IsNullOrWhiteSpace(passphrase) || string.IsNullOrWhiteSpace(privateKey))
            throw new InvalidOperationException("No se encontraron las credenciales necesarias para desencriptar.");

        // Desencriptar
        return await _pgpEncryptionService.DecryptText(encryptedText, privateKey, passphrase);
    }
}



public static class ValidationHelper
{
    public static void ValidateNotNullOrWhiteSpace(string value, string paramName, string errorMessage = null)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException(errorMessage ?? $"{paramName} cannot be empty or null.", paramName);
        }
    }
}


public static void CreateCredential(string name, string userName, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("The credential name cannot be empty or null.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("Username cannot be empty or null.", nameof(userName));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("The secret cannot be empty or null.", nameof(secret));
    }

    try
    {
        if (secret.Length > MAX_SECRET_LENGTH)
        {
            Console.WriteLine($"The secret exceeds {MAX_SECRET_LENGTH} characters. Splitting into fragments...");
            var credentialFragments = BuildPartitionedLongCredential(name, secret);

            foreach (var entry in credentialFragments)
            {
                WriteCredentialSafely(entry.Key, userName, entry.Value);
            }
        }
        else
        {
            WriteCredentialSafely(name, userName, secret);
        }
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error creating credential '{name}': {ex.Message}");
    }
}

private static void WriteCredentialSafely(string name, string userName, string secret)
{
    try
    {
        CredentialManager.WriteCredential(
            applicationName: name,
            userName: userName,
            secret: secret,
            persistence: CredentialPersistence.LocalMachine
        );

        Console.WriteLine($"Credential '{name}' created successfully.");
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Failed to create credential '{name}': {ex.Message}");
    }
}


public static Dictionary<string, string> BuildPartitionedLongCredential(string name, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vac√≠o o ser nulo.", nameof(name));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("El secreto no puede estar vac√≠o o ser nulo.", nameof(secret));
    }

    var partitions = new Dictionary<string, string>();
    int totalFragments = (int)Math.Ceiling((double)secret.Length / MAX_SECRET_LENGTH);

    for (int i = 0; i < totalFragments; i++)
    {
        string fragment = secret.Substring(i * MAX_SECRET_LENGTH, Math.Min(MAX_SECRET_LENGTH, secret.Length - i * MAX_SECRET_LENGTH));
        string fragmentName = $"{name}_part{i}";
        partitions[fragmentName] = fragment;
    }

    return partitions;
}

public static void CreateCredentialFromFile(string name, string userName, string filePath)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vac√≠o o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vac√≠o o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrWhiteSpace(filePath))
    {
        throw new ArgumentException("La ruta del archivo no puede estar vac√≠a o ser nula.", nameof(filePath));
    }

    if (!File.Exists(filePath))
    {
        throw new FileNotFoundException($"El archivo especificado no existe: {filePath}");
    }

    string secret;
    try
    {
        secret = File.ReadAllText(filePath);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
        throw;
    }

    if (string.IsNullOrEmpty(secret))
    {
        Console.Error.WriteLine("El archivo est√° vac√≠o. No se crear√°n credenciales.");
        return;
    }

    var credentialFragments = BuildPartitionedLongCredential(name, secret);

    foreach (var entry in credentialFragments)
    {
        CreateCredential(entry.Key, userName, entry.Value);
    }
}


public static string ReadCredential(string name)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vac√≠o o ser nulo.", nameof(name));
    }

    try
    {
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(name))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        if (credentials.Count == 0)
        {
            throw new InvalidOperationException($"No se encontraron credenciales para el nombre: {name}");
        }

        return string.Concat(credentials.Select(c => c.Password));
    }
    catch (Exception ex)
    {
        // Loggear el error (puedes implementar un sistema de logging como Serilog)
        Console.Error.WriteLine($"Error al leer credenciales: {ex.Message}");
        throw;
    }
}

public static void CreateCredentialFromFile(string name, string userName, string filePath)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vac√≠o o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vac√≠o o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrWhiteSpace(filePath))
    {
        throw new ArgumentException("La ruta del archivo no puede estar vac√≠a o ser nula.", nameof(filePath));
    }

    if (!File.Exists(filePath))
    {
        throw new FileNotFoundException($"El archivo especificado no existe: {filePath}");
    }

    string secret;
    try
    {
        secret = File.ReadAllText(filePath);
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al leer el archivo: {ex.Message}");
        throw;
    }

    if (string.IsNullOrEmpty(secret))
    {
        Console.Error.WriteLine("El archivo est√° vac√≠o. No se crear√°n credenciales.");
        return;
    }

    int totalFragments = (int)Math.Ceiling((double)secret.Length / MAX_SECRET_LENGTH);

    for (int i = 0; i < totalFragments; i++)
    {
        string fragment = secret.Substring(i * MAX_SECRET_LENGTH, Math.Min(MAX_SECRET_LENGTH, secret.Length - i * MAX_SECRET_LENGTH));
        string fragmentName = $"{name}_part{i}";

        CreateCredential(fragmentName, userName, fragment);
    }
}


public static void CreateCredential(string name, string userName, string secret)
{
    if (string.IsNullOrWhiteSpace(name))
    {
        throw new ArgumentException("El nombre de la credencial no puede estar vac√≠o o ser nulo.", nameof(name));
    }

    if (string.IsNullOrWhiteSpace(userName))
    {
        throw new ArgumentException("El nombre de usuario no puede estar vac√≠o o ser nulo.", nameof(userName));
    }

    if (string.IsNullOrEmpty(secret))
    {
        throw new ArgumentException("El secreto no puede estar vac√≠o o ser nulo.", nameof(secret));
    }

    if (secret.Length > MAX_SECRET_LENGTH)
    {
        throw new ArgumentException($"El secreto excede el tama√±o m√°ximo permitido de {MAX_SECRET_LENGTH} caracteres.");
    }

    try
    {
        CredentialManager.WriteCredential(
            applicationName: name,
            userName: userName,
            secret: secret,
            persistence: CredentialPersistence.LocalMachine
        );
    }
    catch (Exception ex)
    {
        Console.Error.WriteLine($"Error al crear la credencial: {ex.Message}");
        throw;
    }
}



using System;
using System.Linq;
using Meziantou.Framework.Win32;

class Program
{
    static void Main()
    {
        string appName = "MyApp";
        var credentials = CredentialManager.EnumerateCredentials()
            .Where(c => c.ApplicationName.StartsWith(appName))
            .OrderBy(c => c.ApplicationName)
            .ToList();

        string fullKey = string.Concat(credentials.Select(c => c.Secret));
        
        Console.WriteLine("Clave reconstruida:\n" + fullKey);
    }
}


using Meziantou.Framework.Win32;
using System;
using System.Text;

public class CredentialManagerHelper
{
    public static void SaveKeyInFragments(string applicationName, string key, int fragmentSize = 2000)
    {
        int totalFragments = (int)Math.Ceiling((double)key.Length / fragmentSize);

        for (int i = 0; i < totalFragments; i++)
        {
            string fragment = key.Substring(i * fragmentSize, Math.Min(fragmentSize, key.Length - i * fragmentSize));
            string fragmentName = $"{applicationName}_Part{i}";

            CredentialManager.WriteCredential(
                applicationName: fragmentName,
                userName: "fragment",
                secret: fragment,
                comment: $"Part {i + 1} of {totalFragments}",
                persistence: CredentialPersistence.LocalMachine);
        }
    }
}

public class CredentialManagerHelper
{
    public static string RetrieveKeyFromFragments(string applicationName)
    {
        StringBuilder keyBuilder = new StringBuilder();
        int partIndex = 0;

        while (true)
        {
            string fragmentName = $"{applicationName}_Part{partIndex}";
            var credential = CredentialManager.ReadCredential(fragmentName);

            if (credential == null) break; // Termina si no encuentra m√°s fragmentos

            keyBuilder.Append(credential.Password);
            partIndex++;
        }

        return keyBuilder.ToString();
    }
}


using System;
using System.IO;
using PgpCore;
using System.Threading.Tasks;

class Program
{
    static async Task Main()
    {
        Console.Write("Ingrese el texto a encriptar: ");
        string inputText = Console.ReadLine();
        
        string publicKey = GetPublicKeyFromWCM();
        string privateKey = GetPrivateKeyFromWCM();
        string passphrase = "TuPassphrase"; // Opcional si la clave privada tiene una contrase√±a
        
        string encryptedText = await EncryptText(inputText, publicKey);
        Console.WriteLine("Texto Encriptado:\n" + encryptedText);
        
        string decryptedText = await DecryptText(encryptedText, privateKey, passphrase);
        Console.WriteLine("Texto Desencriptado:\n" + decryptedText);
    }

    static string GetPublicKeyFromWCM()
    {
        // Aqu√≠ ir√≠a la l√≥gica para obtener la clave p√∫blica desde el Windows Credential Manager
        return "ClaveP√∫blicaFalsa";
    }

    static string GetPrivateKeyFromWCM()
    {
        // Aqu√≠ ir√≠a la l√≥gica para obtener la clave privada desde el Windows Credential Manager
        return "ClavePrivadaFalsa";
    }

    static async Task<string> EncryptText(string text, string publicKey)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(text)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(publicKey)))
        {
            await pgp.EncryptStreamAsync(inputStream, outputStream, keyStream);
            return Convert.ToBase64String(outputStream.ToArray());
        }
    }

    static async Task<string> DecryptText(string encryptedText, string privateKey, string passphrase)
    {
        using (var pgp = new PGP())
        using (var inputStream = new MemoryStream(Convert.FromBase64String(encryptedText)))
        using (var outputStream = new MemoryStream())
        using (var keyStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(privateKey)))
        {
            await pgp.DecryptStreamAsync(inputStream, outputStream, keyStream, passphrase);
            return System.Text.Encoding.UTF8.GetString(outputStream.ToArray());
        }
    }
}
