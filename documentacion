/// <summary>
/// Retrieves employee information from the HR API using the subject from the authenticated token.
/// </summary>
/// <returns>
/// An <see cref="Emplafo"/> object containing the employee's personal and organizational data.
/// </returns>
/// <exception cref="Exception">
/// Thrown when token validation fails or when employee information is incomplete or missing.
/// </exception>
private Emplafo GetEmpinfo()

/// <summary>
/// Maps the HR API response to the internal <see cref="Emplafo"/> data structure.
/// </summary>
/// <param name="empinfoHRApi">The employee information received from the HR API.</param>
/// <returns>
/// A transformed <see cref="Emplafo"/> object containing normalized values for application use.
/// </returns>
private Emplafo ParseEmpinfoHRApi(EmpInfoHRApiResponse empinfoHRApi)





/// <summary>
/// Redirects the user to a legacy report page if the current role is flagged for report redirection.
/// </summary>
/// <param name="reportID">The report identifier used to build the redirection URL.</param>
private void ValidateIfRedirectToReport(string reportID)

/// <summary>
/// Initializes the dataset with template information based on the user's role.
/// </summary>
/// <param name="roleID">The identifier of the user's role.</param>
private void InitializeDataset(string roleID)

/// <summary>
/// Retrieves the report ID to be used during authentication and redirection flows.
/// </summary>
/// <returns>A report identifier string.</returns>
private string GetReportId()

/// <summary>
/// Validates that the token information for the current user contains a valid subject (sub).
/// </summary>
/// <exception cref="Exception">
/// Thrown when the token information or subject value is missing.
/// </exception>
private void ValidateTokenEmpinfo()

/// <summary>
/// Validates that the employee information retrieved from HR API contains a valid employee number.
/// </summary>
/// <param name="empinfo">The <see cref="EmpInfoHRApiResponse"/> instance to validate.</param>
/// <exception cref="Exception">
/// Thrown when the employee information or employee number is null.
/// </exception>
private void ValidateEmpInfo(EmpInfoHRApiResponse empinfo)

/// <summary>
/// Converts a numeric string to a 10-digit string by left-padding with zeros.
/// </summary>
/// <param name="number">The input number as a string.</param>
/// <returns>A 10-digit left-padded string representation of the input.</returns>
private static string ConvertToTenDigitString(string number)



/// <summary>
/// Redirects the user to a frameset view based on the route prefix and role, if redirection is allowed.
/// </summary>
/// <param name="allowRedirect">Specifies whether redirection to the frameset should be performed.</param>
/// <param name="templateType">The template type to include in the redirect URL.</param>
/// <param name="roleID">The user's role identifier used in the redirection.</param>
/// <exception cref="HttpException">
/// Thrown when the base path cannot be determined and the user is redirected to the AccessDenied page.
/// </exception>
private void ValidateIfRedirectToFrameset(bool allowRedirect, string templateType, string roleID)

/// <summary>
/// Validates whether the request originates from an allowed Scotiaworld domain; otherwise, redirects to AccessDenied.
/// </summary>
/// <exception cref="HttpException">
/// Thrown when the request comes from a different host and does not match the expected Scotiaworld domain.
/// </exception>
private void ValidateIfFromScotiaworld()





/// <summary>
/// Retrieves application metadata configuration based on the current request URL and route prefix.
/// </summary>
/// <returns>
/// An <see cref="AppMetadata"/> object containing application-level configuration values.
/// </returns>
/// <exception cref="HttpException">
/// Thrown when the required configuration section is missing, triggering a redirection to the AccessDenied page.
/// </exception>
private AppMetadata ExtractAppMetadata()




/// <summary>
/// Verifies the user's authentication state, retrieves user and role information,
/// initializes session variables, and conditionally redirects based on role or template type.
/// </summary>
/// <param name="allowTemplateTypeRedirect">
/// Indicates whether redirection to a specific template-based view should occur after authentication.
/// </param>
/// <exception cref="Exception">
/// Thrown when an unexpected error occurs during authentication, metadata loading, or session initialization.
/// </exception>
public void CheckForAuthentication(bool allowTemplateTypeRedirect = true)





/// <summary>
/// Executes custom initialization logic to validate authentication and set redirection URI if necessary.
/// </summary>
/// <param name="e">The event data associated with the page initialization.</param>
protected override void OnInit(EventArgs e)
{
    ValidateAndBuildRedirectToWam();
    base.OnInit(e);
}

/// <summary>
/// Validates the user's authentication state and sets a redirection URI for WAM login if not authenticated.
/// </summary>
/// <exception cref="HttpException">Thrown when redirection to the AccessDenied page is triggered due to missing route resolution.</exception>
private void ValidateAndBuildRedirectToWam()




/// <summary>
/// Represents the base class for all WebReport pages that require authentication,
/// HRAPI integration, session initialization, and role-based redirection logic.
/// 
/// <para>
/// The <see cref="WebReportBase"/> class extends <see cref="AuthPage"/> and centralizes
/// the authentication flow and session context initialization for authenticated users.
/// It performs key tasks such as:
/// </para>
/// <list type="bullet">
///   <item>Validating user authentication via token or WAM redirection</item>
///   <item>Fetching user metadata from HRAPI using a secure client assertion</item>
///   <item>Loading dynamic labels and templates based on the user's role and language</item>
///   <item>Tracking page access and managing redirection to role-based views or reports</item>
/// </list>
/// 
/// <para>
/// This class is typically inherited by report pages that rely on WAM/OIDC login 
/// and require access to session-level employee information and permissions.
/// </para>
/// </summary>
/// <remarks>
/// This class integrates with multiple services:
/// <list type="bullet">
///   <item><see cref="TrackVisitors"/> for access auditing</item>
///   <item><see cref="HRReportService"/> for template and report metadata</item>
///   <item><see cref="HrApiClientManager"/> for retrieving employee info via HRAPI</item>
/// </list>
/// 
/// It also uses shared configuration from <c>GlobalStatics</c> and WAM route management
/// via <c>CustomRedirectUri</c> cookies or context values.
/// </remarks>
/// <seealso cref="AuthPage"/>





# OAuth Authentication Implementation ‚Äî ASP.NET MVC (.NET Framework 4.7.2)

## Overview

This project implements **OAuth 2.0** authentication and **OpenID Connect (OIDC)** in an **ASP.NET MVC application** targeting **.NET Framework 4.7.2**.  
Authentication is delegated to **WAM** (Web Access Manager) using OpenID Connect, and a secure cookie is used to maintain session state. After authentication, the app retrieves employee information from an external **HR API**.

---

## Key Features

- ‚úÖ OAuth 2.0 / OIDC-based authentication via WAM.
- üç™ Cookie-based authentication lifecycle.
- üîÑ Dynamic redirection logic based on the request domain (HRPassport or ScotiaWorld).
- üîê Secure secret retrieval from **Azure Key Vault (AKV)**.
- üßæ Claims extraction and validation from the ID token.
- üë§ Post-login user data enrichment from HRAPI (e.g., name, language, employee ID).

---

## Versions & Libraries

| Component         | Target Framework     | Purpose                                      |
|------------------|----------------------|----------------------------------------------|
| MVC App           | .NET Framework 4.7.2 | Web application entrypoint and controllers   |
| OwinOAuthLib      | .NET Standard 2.0    | OAuth/OIDC authentication configuration      |
| AspOwinOAuth      | .NET Framework 4.7.2 | WAM redirection & token claim extraction     |
| CryptoPGP         | .NET Standard 2.0    | Retrieves secrets from Azure Key Vault       |
| HRAPILib          | .NET Standard 2.0    | Retrieves authenticated user‚Äôs profile info  |

---

## Architectural Decisions

- **MVC Pattern**  
  The project uses the ASP.NET MVC pattern to cleanly separate concerns across models, views, and controllers.

- **[Authorize] on BaseController**  
  All controllers inherit from a `BaseController` that enforces authentication via the `[Authorize]` attribute.

- **Token Validation in Global.asax**  
  The OWIN middleware validates tokens and extracts claims during `Application_PostAuthenticateRequest`.

- **Session Hydration via Filter**  
  A custom `EmployeeInformationFilterAttribute` ensures the employee information is fetched only once and stored in session.

- **Decoupled OAuth & WAM Logic**  
  `OwinOAuthLib` focuses on cookie+OIDC config, while `AspOwinOAuth` handles redirection and token introspection separately.

---

## Flow Summary

1. **Initial Request**  
   User accesses a protected controller that inherits from `BaseController`. The app checks if they are authenticated.

2. **Redirection to WAM**  
   If not authenticated, WAM redirection is triggered using `AspOwinOAuth`. The origin is determined dynamically.

3. **Login & Return**  
   User logs in via WAM and is redirected back to the app with an ID token and access token.

4. **Token Validation & Claim Extraction**  
   `OwinOAuthLib` validates the token and establishes an authenticated session via a secure cookie.

5. **Session Data Setup**  
   `EmployeeInformationFilterAttribute` invokes `HRAPILib` to retrieve and store the employee‚Äôs info in session.

6. **Subsequent Requests**  
   Cookies maintain session continuity, and `SessionHelper` provides easy access to the authenticated user‚Äôs data.

---

## Required NuGet Libraries and Versions

| Library                                          | Version     | Purpose                                     |
|--------------------------------------------------|-------------|---------------------------------------------|
| Microsoft.IdentityModel.Tokens                   | 8.8.0.0     | Token signing and validation                |
| Microsoft.IdentityModel.Protocols.OpenIdConnect  | 5.3.0.0     | OIDC metadata and protocol support          |
| Microsoft.Owin                                   | 4.2.2.0     | Core OWIN components                        |
| Microsoft.Owin.Host.System.Web                   | 4.2.2.0     | Integrates OWIN pipeline into ASP.NET       |
| Microsoft.Owin.Security                          | 4.2.2.0     | Base authentication middleware              |
| Microsoft.Owin.Security.Cookies                  | 4.2.2.0     | Cookie-based session handling               |
| Microsoft.Owin.Security.OpenIdConnect            | 4.2.2.0     | OpenID Connect client middleware            |
| Owin                                             | 1.0.0.0     | OWIN abstractions                           |
| System.IdentityModel.Tokens.Jwt                  | 8.8.0.0     | Token parsing and JWT decoding              |
| System.Text.Json                                 | 9.0.0.3     | JSON (de)serialization                      |
| BouncyCastle.Crypto                              | 1.8.9.0     | PEM key reading and JWT signing             |
| Azure.Core                                       | 1.44.1.0    | Azure SDK core abstraction layer            |
| Azure.Identity                                   | 1.13.2.0    | Managed identity / credential auth          |
| Azure.Security.KeyVault.Secrets                  | 4.7.0.0     | Azure Key Vault secret retrieval            |

---

## Recommended Practices

- üîê Store all client secrets and PEM keys securely in Azure Key Vault.
- ‚úÖ Implement detailed logging with `LogHelper` to trace authentication and data retrieval issues.
- üß™ Use integration testing with test tokens and dummy HRAPI endpoints when developing locally.
- üîÅ Rotate keys and tokens securely and monitor WAM token expirations and scope changes.

---

## License

This project is proprietary and intended for internal enterprise use only.








/// <summary>
/// Handles the <c>PostAuthenticateRequest</c> event in the ASP.NET application lifecycle.
/// This event is triggered after the user has been authenticated by the OWIN pipeline.
/// 
/// The method validates that the user is authenticated and that a valid ID token is present.
/// If either check fails, an error is logged.
/// </summary>
/// <param name="sender">The source of the event, typically the application object.</param>
/// <param name="e">Event arguments related to the HTTP request.</param>
protected void Application_PostAuthenticateRequest(object sender, EventArgs e)


/// <summary>
/// Handles the <c>BeginRequest</c> event in the ASP.NET application lifecycle.
/// Determines the appropriate redirect URI based on the request host, and sets
/// a secure "OriginalHost" cookie for downstream use (e.g., during WAM authentication).
/// </summary>
/// <param name="sender">The source of the event (usually the application instance).</param>
/// <param name="e">Event arguments associated with the request.</param>
/// <exception cref="Exception">
/// Thrown if no matching redirect URI is found based on the request path or forwarded headers.
/// This usually indicates a misconfiguration in the route prefixes or hostnames.
/// </exception>
protected void Application_BeginRequest(object sender, EventArgs e)


/// <summary>
/// Custom action filter that retrieves employee information from HRAPI and stores it in the session
/// if it has not already been loaded. This ensures that controllers and views have access to
/// the user's profile information, such as name, language, and employee number.
/// </summary>
[AttributeUsage(AttributeTargets.Method, Inherited = true, AllowMultiple = false)]
public class EmployeeInformationFilterAttribute : ActionFilterAttribute
{
    /// <summary>
    /// Token identity information retrieved from the WAM token, used for querying HRAPI.
    /// </summary>
    public TokenEmpinfo TokenEmplafo { get; set; }

    private SessionHelper _currentSession;

    /// <summary>
    /// Called before an action method is invoked. This method ensures that employee
    /// information is present in the session. If not, it retrieves it from HRAPI and sets it.
    /// If the user has a requested page, the request is redirected.
    /// </summary>
    /// <param name="filterContext">The context of the currently executing action.</param>
    public override void OnActionExecuting(System.Web.Mvc.ActionExecutingContext filterContext)
    {
        LogHelper.Log("[EmployeeInformationFilterAttribute]", level: LogHelper.LogLevel.Debug);

        HttpSessionStateBase sessionState = filterContext.HttpContext.Session;
        _currentSession = new SessionHelper(sessionState);

        if (_currentSession.Userinfo == null)
        {
            var empinfo = GetEmployeeInfo();
            _currentSession.Userinfo = empinfo;

            if (string.IsNullOrEmpty(_currentSession.Userinfo.LanguageCode))
                LogHelper.Log("Employee information language is missing.", _currentSession.SessionID, LogHelper.LogLevel.Warning);

            if (string.IsNullOrEmpty(_currentSession.Userinfo.CountryCode))
                LogHelper.Log("Employee information country is missing.", _currentSession.SessionID, LogHelper.LogLevel.Warning);

            if (string.IsNullOrEmpty(_currentSession.Userinfo.EmployeeNumber))
                LogHelper.Log("Employee information employee number is missing.", _currentSession.SessionID, LogHelper.LogLevel.Warning);

            if (!string.IsNullOrEmpty(_currentSession.Userinfo.RequestedPage))
            {
                LogHelper.Log($"{_currentSession.Userinfo.RequestedPage} was requested. Redirecting", _currentSession.SessionID);

                _currentSession.RequestedPage = _currentSession.Userinfo.RequestedPage;

                filterContext.Result = new RedirectToRouteResult(
                    new RouteValueDictionary
                    {
                        { "controller", "Info" },
                        { "action", "Replaced" }
                    });
            }
        }
    }

    /// <summary>
    /// Retrieves employee information from HRAPI and parses it into the local model.
    /// </summary>
    /// <returns>An instance of <see cref="EmployeeInfo"/> populated with data from HRAPI.</returns>
    /// <exception cref="Exception">
    /// Thrown if the token is invalid, HRAPI call fails, or the response is invalid.
    /// </exception>
    private EmployeeInfo GetEmployeeInfo()
    {
        try
        {
            LogHelper.Log("Execute [GetEmployeeInfo] HR API", level: LogHelper.LogLevel.Informational);

            ValidateTokenEmpinfo();

            HrApiClientManager hrApiClientManager = new HrApiClientManager();

            HrApiProperties.EndpointAccessToken = ConfigurationHelper.HRAPIEndpointAccessToken;
            HrApiProperties.EndpointEmployees = ConfigurationHelper.HRAPIEndpointEmployees;
            HrApiProperties.Scope = ConfigurationHelper.HRAPIScope;
            HrApiProperties.UrlAudience = ConfigurationHelper.HRAPIUrlAudience;

            var taskClientId = Task.Run(async () => await AKVProperties.Singleton.HRApiClientId);
            var taskPrivateKeyPem = Task.Run(async () => await AKVProperties.Singleton.HRApiPrivateKeyPem);

            HrApiProperties.ClientId = taskClientId.Result;
            HrApiProperties.PrivateKeyPem = taskPrivateKeyPem.Result;

            LogHelper.Log($"[EmployeeInformationFilterAttribute] TokenEmplafo: {TokenEmplafo?.Sub}", level: LogHelper.LogLevel.Debug);

            var task = Task.Run(async () => await hrApiClientManager.GetEmployeeInfo(TokenEmplafo.Sub));
            var empinfo = task.Result;

            ValidateEmpinfo(empinfo);

            return ParseEmpinfoHRApi(empinfo);
        }
        catch (Exception e)
        {
            string msg = "There was a problem getting employee information from HRAPI.";
            LogHelper.Log($"{msg}. {e.Message}. {e.InnerException?.Message}", level: LogHelper.LogLevel.Error);
            throw new Exception(msg);
        }
    }

    /// <summary>
    /// Converts the HRAPI response into a strongly typed <see cref="EmployeeInfo"/> object.
    /// </summary>
    /// <param name="empinfoHRApi">The raw HRAPI employee response.</param>
    /// <returns>The mapped <see cref="EmployeeInfo"/> model.</returns>
    private EmployeeInfo ParseEmpinfoHRApi(EmpInfoHRApiResponse empinfoHRApi)
    {
        return new EmployeeInfo
        {
            FirstName = empinfoHRApi.FirstName,
            LastName = empinfoHRApi.LastName,
            EmployeeNumber = ConvertToLenDigitString(empinfoHRApi.EmployeeNumber),
            LanguageCode = LanguageCode.GetLanguageCode(empinfoHRApi.DefaultLocale),
            CountryCode = empinfoHRApi.ContactInfo?.Address?.Country ?? CountryCode.DEFAULT_COUNTRY,
            PositionId = empinfoHRApi.Position?.Code
        };
    }

    /// <summary>
    /// Validates the WAM token and extracts the employee's subject identifier.
    /// </summary>
    /// <exception cref="Exception">Thrown if the token is missing or invalid.</exception>
    private void ValidateTokenEmpinfo()
    {
        TokenEmplafo = new TokenEmpinfo();
        TokenEmplafo.Sub = TokenHelper.GetSub();

        if (string.IsNullOrEmpty(TokenEmplafo.Sub))
        {
            string msg = "Employee information could not be retrieved from the WAM token.";
            LogHelper.Log(msg, level: LogHelper.LogLevel.Error);
            throw new Exception(msg);
        }
    }

    /// <summary>
    /// Validates the HRAPI response to ensure that it contains an employee number.
    /// </summary>
    /// <param name="empinfo">The HRAPI employee response object.</param>
    /// <exception cref="Exception">Thrown if the response is null or lacks an employee number.</exception>
    private void ValidateEmpinfo(EmpInfoHRApiResponse empinfo)
    {
        if (empinfo == null || string.IsNullOrEmpty(empinfo.EmployeeNumber))
        {
            string msg = "Employee information could not be retrieved from HRAPI.";
            LogHelper.Log(msg, level: LogHelper.LogLevel.Error);
            throw new Exception(msg);
        }
    }

    /// <summary>
    /// Pads a numeric employee ID string with leading zeroes to ensure a fixed 10-digit format.
    /// </summary>
    /// <param name="number">The employee number string to normalize.</param>
    /// <returns>The normalized employee number string with leading zeroes.</returns>
    public static string ConvertToLenDigitString(string number)
    {
        return number.PadLeft(10, '0');
    }
}



/// <summary>
/// Base controller class for all MVC controllers in the application that require authentication.
/// 
/// This class enforces that all inheriting controllers are protected by the <see cref="AuthorizeAttribute"/>,
/// ensuring that only authenticated users can access their actions.
/// </summary>


/// <summary>
/// Provides utility methods for mapping and normalizing language codes to standard internal values.
/// </summary>
public static class LanguageCode
{
    /// <summary>
    /// The default language code used when no match is found or input is null.
    /// </summary>
    private const string DEFAULT_LANGUAGE = "EN";

    /// <summary>
    /// A dictionary mapping full language-culture codes to simplified internal language codes.
    /// </summary>
    public static readonly Dictionary<string, string> LanguageMap = new Dictionary<string, string>
    {
        { "en.US", "EN" },
        { "fr.FR", "FR" },
        { "es.ES", "ES" }
    };

    /// <summary>
    /// Resolves a normalized internal language code from a full language input (e.g., "en.US").
    /// </summary>
    /// <param name="languageCode">The input language code, typically from user profile or system locale.</param>
    /// <returns>
    /// The mapped internal language code (e.g., "EN", "FR", "ES").
    /// Returns "EN" if the input is null or not found in the dictionary.
    /// </returns>
    public static string GetLanguageCode(string languageCode)
    {
        if (languageCode == null)
        {
            return DEFAULT_LANGUAGE;
        }

        if (LanguageMap.TryGetValue(languageCode, out string value))
        {
            return value;
        }

        LogHelper.Log($"[LanguageCode] The language [{languageCode}] is not in the dictionary.", level: LogHelper.LogLevel.Error);
        return DEFAULT_LANGUAGE;
    }
}







<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <NoWarn>$(NoWarn);1591</NoWarn> <!-- (opcional) suprime warnings por falta de comentarios -->
</PropertyGroup>



# HRAPI Lib

## Overview

**HRAPI Lib** is a .NET Standard 2.0 library designed to securely retrieve employee information from a remote HRAPI service.  
It supports OAuth 2.0 authentication using client assertion JWTs signed with a private RSA key in PEM format.

The library is built for use in enterprise-grade .NET applications that require secure, programmatic access to HR data using modern authentication standards.

---

## Key Features

- üîê **OAuth 2.0 Authentication with Client Assertion (JWT)**  
  Generates a signed JWT using a private RSA key and uses it to obtain an access token from the HRAPI token endpoint.

- üë§ **Employee Information Retrieval**  
  Fetches employee data from the HRAPI endpoint by ScotiaID using secure bearer token authorization.

- üìÑ **PEM Key Support via BouncyCastle**  
  Parses RSA private keys in PEM format for JWT signing.

- üìä **Automatic Claim Construction**  
  Builds standard claims (iss, sub, aud, exp, jti, nbf) for client assertion compliance.

- üåê **Proxy Support for Corporate Networks**  
  Configures all outgoing HTTP requests with proxy support by default.

---

## Target Framework

- **.NET Standard 2.0**  
  Compatible with:
  - .NET Framework 4.6.1 and later
  - .NET Core 2.0+
  - .NET 5/6/7+

---

## Installation

Add the `HRAPI Lib` project to your solution or consume it as a private library.

Required NuGet dependencies:

```xml
<PackageReference Include="BouncyCastle" Version="1.8.9" />
<PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.8.0" />
<PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.8.0" />
<PackageReference Include="System.Text.Json" Version="9.0.3" />

## Dependencies

| NuGet Package                            | Version | Description                                                 |
|-----------------------------------------|---------|-------------------------------------------------------------|
| BouncyCastle                            | 1.8.9   | Provides cryptographic support for parsing PEM RSA keys     |
| Microsoft.IdentityModel.Tokens          | 8.8.0   | Used to create and sign JWTs with security credentials      |
| System.IdentityModel.Tokens.Jwt         | 8.8.0   | Handles JWT creation, serialization, and validation         |
| System.Text.Json                         | 9.0.3   | Used to serialize and deserialize HTTP responses (JSON)     |


## Library Structure

| Component               | Purpose                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| `HrApiClientManager`    | Facade for retrieving employee data; coordinates token creation and request. |
| `HRApiClientService`    | Executes HTTP calls to token and employee endpoints.                    |
| `ClientAssertionService`| Builds signed client assertion JWTs using RSA PEM private keys.         |
| `HrApiProperties`       | Holds endpoint URLs, client ID, scopes, audience, and key configuration.|
| `TokenResponse`         | Model representing OAuth access token response.                         |
| `EmpInfoHRApiResponse`  | Model for employee profile data from HRAPI.                             |
| `ValidationHelper`      | Utility class for validating required arguments (not shown here).       |

---

## Limitations

- üîë The library expects the **RSA private key to be provided in PEM format**; no other formats (e.g., PFX, XML) are supported.
- üì¶ The library does not handle token refresh or retry logic ‚Äî this must be implemented at the calling level if needed.
- üß† Sensitive strings (e.g., keys, tokens) are handled in memory; it's your responsibility to protect them if required.
- ‚òÅÔ∏è The audience (`aud`) used in JWTs must match the expected OAuth token endpoint in HRAPI ‚Äî mismatches will result in 401 responses.
- üö´ No built-in caching for tokens or employee responses ‚Äî designed for stateless request-per-call use cases.




/// <summary>
/// Provides helper methods for generating client assertion JWTs
/// using RSA private keys in PEM format.
/// 
/// These tokens are typically used for client authentication in OAuth 2.0 flows
/// where the grant type is `client_credentials` with `client_assertion`.
/// </summary>
internal class ClientAssertionService
{
    /// <summary>
    /// Generates a signed JWT (client assertion) using the provided client ID, PEM-formatted RSA private key,
    /// and token audience (typically the OAuth token endpoint).
    /// </summary>
    /// <param name="clientId">The client ID (also used as issuer and subject in the token).</param>
    /// <param name="privateKeyPem">The RSA private key in PEM format used to sign the JWT.</param>
    /// <param name="urlAud">The audience for the token, usually the token endpoint URL.</param>
    /// <returns>A signed JWT string representing the client assertion.</returns>
    /// <exception cref="Exception">Thrown if the private key is invalid or unreadable.</exception>
    public static string GenerateClientAssertionFromPem(string clientId, string privateKeyPem, string urlAud)
    {
      
    }

    /// <summary>
    /// Parses a PEM-encoded RSA private key string and returns a usable .NET RSA instance.
    /// </summary>
    /// <param name="pem">PEM-encoded RSA private key.</param>
    /// <returns>An RSA instance usable for signing.</returns>
    /// <exception cref="Exception">Thrown if the key is not in valid RSA PEM format.</exception>
    private static RSA LoadRsaPrivateKeyFromPem(string pem)
    {
      
    }
}



/// <summary>
/// Handles HTTP communication with the HRAPI service, including:
/// - Fetching employee data
/// - Obtaining access tokens via client assertion or client secret
/// 
/// This service uses proxy-aware HttpClient configuration and attaches standard BNS headers.
/// </summary>
internal class HRApiClientService
{
    /// <summary>
    /// Sends a request to the HRAPI employee endpoint to retrieve employee information by ScotiaID.
    /// Includes standard headers required by BNS (e.g., trace ID, channel ID).
    /// </summary>
    /// <param name="scotiaid">The ScotiaID of the employee to query.</param>
    /// <param name="token">The access token obtained via OAuth client assertion.</param>
    /// <returns>An <see cref="EmpInfoHRApiResponse"/> object with the most recently updated employee data.</returns>
    /// <exception cref="Exception">Thrown if the API request fails or the response is invalid.</exception>
    public async Task<EmpInfoHRApiResponse> GetEmployeeInfo(string scotiaid, TokenResponse token)
    {
       
    }

    /// <summary>
    /// Selects the most recently updated employee from a list of employee records.
    /// </summary>
    /// <param name="employees">A list of employee records returned by the HRAPI.</param>
    /// <returns>The most recently updated employee record.</returns>
    private EmpInfoHRApiResponse GetMostRecentlyUpdatedEmployee(List<EmpInfoHRApiResponse> employees)
    {
        return employees.OrderByDescending(e => DateTime.Parse(e.LastModifiedTimestamp)).FirstOrDefault();
    }

    /// <summary>
    /// Obtains an OAuth access token from the HRAPI token endpoint using a client assertion JWT.
    /// </summary>
    /// <param name="clientAssertion">A signed JWT representing the client assertion.</param>
    /// <returns>A <see cref="TokenResponse"/> containing the access token.</returns>
    public async Task<TokenResponse> GetTokenWithAssertion(string clientAssertion)
    {
     
    }

    /// <summary>
    /// Obtains an OAuth access token using client ID and client secret authentication.
    /// </summary>
    /// <returns>A <see cref="TokenResponse"/> containing the access token.</returns>
    public async Task<TokenResponse> GetToken()
    {
      
    }
}



/// <summary>
/// Manages the process of retrieving employee information from the HRAPI service.
/// Handles authentication using a client assertion JWT and sends the request to the employee endpoint.
/// </summary>
public class HrApiClientManager
{
    /// <summary>
    /// Asynchronously retrieves employee information from the HRAPI endpoint using the provided Scotia ID.
    /// 
    /// This method:
    /// - Validates required configuration values.
    /// - Generates a client assertion using the provided PEM private key.
    /// - Requests an access token from HRAPI using the client assertion.
    /// - Queries the employee endpoint for employee data using the obtained access token.
    /// </summary>
    /// <param name="scotiaid">The ScotiaID (unique employee identifier) to look up.</param>
    /// <returns>An <see cref="EmplafoHBApiResponse"/> object containing employee data.</returns>
    /// <exception cref="Exception">Thrown if any required parameter is missing or if the API call fails.</exception>
    public async Task<EmplafoHBApiResponse> GetEmployeeInfo(string scotiaid)



# CryptoPGP

## Overview

**CryptoPGP** is a .NET Standard 2.0 utility library designed to simplify secure data handling in enterprise applications.  
It provides a unified interface for:

- Encrypting and decrypting text using **PGP**.
- Storing and retrieving secrets from the **Windows Credential Manager**.
- Accessing secrets from **Azure Key Vault**.

The library is designed to work in layered or service-oriented architectures and is ideal for .NET applications that require secure handling of credentials and encrypted data.

---

## Key Features

- üîê **PGP Encryption and Decryption**  
  Asynchronous encryption and decryption with public/private key pairs using [PgpCore](https://github.com/mattosaurus/PgpCore).

- üß© **Credential Fragmentation Support**  
  Handles long secrets by splitting them into multiple entries when saving to the Windows Credential Manager.

- üîë **Secure Credential Storage and Retrieval**  
  Read and write secrets to the Windows Credential Manager, with optional username validation.

- ‚òÅÔ∏è **Azure Key Vault Integration**  
  Fetch secrets securely using `DefaultAzureCredential`, suitable for enterprise environments with managed identity or client secret authentication.

- üß™ **Base64 Helpers**  
  Built-in methods to encrypt to and decrypt from Base64 strings.

- üß± **Central Access Point**  
  `CryptoManager` serves as a single-entry service for encryption, decryption, credential operations, and secret retrieval.

---

## Target Framework

- **.NET Standard 2.0**  
  Compatible with a wide range of platforms, including:
  - .NET Framework (‚â• 4.6.1)
  - .NET Core (‚â• 2.0)
  - .NET 5/6/7+

---

## Installation

Add the `CryptoPGP` project to your solution or include it via a library package.

Required NuGet dependencies:

```xml
<PackageReference Include="AdysTech.CredentialManager" Version="2.6.0" />
<PackageReference Include="Azure.Identity" Version="1.13.2" />
<PackageReference Include="Azure.Security.KeyVault.Secrets" Version="4.7.0" />
<PackageReference Include="PgpCore" Version="6.5.1" />


## Library Structure

| Component            | Purpose                                                                 |
|----------------------|-------------------------------------------------------------------------|
| `CryptoManager`      | Main facade for all operations: encrypt, decrypt, key vault, credentials. |
| `PGPEncryptionService` | Handles async PGP encryption and decryption using PgpCore.              |
| `WCMService`         | Manages read/write operations to Windows Credential Manager.             |
| `AKVService`         | Connects to Azure Key Vault and fetches secrets using DefaultAzureCredential. |
| `Credential`         | Model for representing name/username/password credential triples.        |
| `Constants`          | Central definitions for key names and secret limits.                     |
| `ValidationHelper`   | Utility class to enforce required parameters (not shown here).           |

---

## Limitations

- ‚ùó This library **does not manage authentication or configuration for Azure Key Vault** ‚Äî your application must configure `DefaultAzureCredential` appropriately (e.g., via environment or managed identity).
- üì¶ The Windows Credential Manager has size limits (~1280 characters per secret); this is handled automatically through fragmentation.
- üß† It is your responsibility to secure the `publicKeyPath`, base64 strings, or any other in-memory secrets ‚Äî no secure wiping or memory protection is provided.
- üîê Only ASCII-armored keys and PGP messages are supported via PgpCore.


## Dependencies

| NuGet Package                          | Version  | Description                                                |
|---------------------------------------|----------|------------------------------------------------------------|
| AdysTech.CredentialManager            | 2.6.0    | Provides access to Windows Credential Manager APIs         |
| Azure.Identity                        | 1.13.2   | Enables secure credential management for Azure services    |
| Azure.Security.KeyVault.Secrets       | 4.7.0    | Client library for accessing Azure Key Vault secrets       |
| PgpCore                               | 6.5.1    | Simplified wrapper around BouncyCastle for PGP operations  |




/// <summary>
/// Central manager class for encryption, decryption, secret retrieval, and credential operations
/// in the CryptoPGP library. This class acts as a facade for securely handling secrets via:
/// - Azure Key Vault
/// - Windows Credential Manager
/// - PGP encryption/decryption (with base64 support)
/// </summary>
public class CryptoManager
{
    private static readonly WCMService wcmService = new WCMService();
    private static readonly PGPEncryptionService pgpEncryptionService = new PGPEncryptionService();
    private static readonly AKVService akvService = new AKVService();

    /// <summary>
    /// Decrypts a Base64-encoded PGP encrypted string.
    /// </summary>
    /// <param name="base64EncryptedText">The encrypted text in Base64 format.</param>
    /// <returns>The decrypted plain text string.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the decryption fails or input is invalid.</exception>
    public static async Task<string> DecryptBase64(string base64EncryptedText)
    {
        try
        {
            ValidationHelper.ValidateRequired(base64EncryptedText, nameof(base64EncryptedText));

            string pgpEncryptedText = Encoding.UTF8.GetString(Convert.FromBase64String(base64EncryptedText));
            string decryptedText = await Decrypt(pgpEncryptedText);

            return decryptedText;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred during decryption", ex);
        }
    }

    /// <summary>
    /// Decrypts a PGP encrypted string using private key and passphrase from the Windows Credential Manager.
    /// </summary>
    /// <param name="encryptedText">The encrypted text (PGP ASCII-armored).</param>
    /// <returns>The decrypted plain text string.</returns>
    /// <exception cref="InvalidOperationException">Thrown when decryption fails or required secrets are missing.</exception>
    public static async Task<string> Decrypt(string encryptedText)
    {
        try
        {
            ValidationHelper.ValidateRequired(encryptedText, nameof(encryptedText));

            Credential passphrase = wcmService.ReadCredential(Constants.IIS_PGP_PASSPHRASE, null);
            Credential privateKeyBase64 = wcmService.ReadFragmentedCredential(Constants.IIS_PGP_PRIVATEKEY);

            string privateKey = Encoding.UTF8.GetString(Convert.FromBase64String(privateKeyBase64.Password));

            ValidationHelper.ValidateRequired(passphrase.Password, nameof(passphrase));
            ValidationHelper.ValidateRequired(privateKey, nameof(privateKey));

            string decryptedText = await pgpEncryptionService.DecryptText(encryptedText, privateKey, passphrase.Password);

            return decryptedText;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred during decryption", ex);
        }
    }

    /// <summary>
    /// Encrypts plain text using a PGP public key and returns the result as a Base64 string.
    /// </summary>
    /// <param name="plainText">The plain text to encrypt.</param>
    /// <param name="publicKeyPath">Path to the public key file (ASCII-armored).</param>
    /// <returns>The encrypted string encoded in Base64.</returns>
    /// <exception cref="InvalidOperationException">Thrown when encryption fails or input is invalid.</exception>
    public static async Task<string> EncryptToBase64(string plainText, string publicKeyPath)
    {
        try
        {
            ValidationHelper.ValidateRequired(plainText, nameof(plainText));
            ValidationHelper.ValidateRequired(publicKeyPath, nameof(publicKeyPath));

            string encryptedText = await Encrypt(plainText, publicKeyPath);
            string base64EncryptedText = Convert.ToBase64String(Encoding.UTF8.GetBytes(encryptedText));

            return base64EncryptedText;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred during encryption", ex);
        }
    }

    /// <summary>
    /// Encrypts plain text using a PGP public key read from a file.
    /// </summary>
    /// <param name="plainText">The text to encrypt.</param>
    /// <param name="publicKeyPath">File path to the PGP public key.</param>
    /// <returns>The encrypted PGP message in ASCII-armored format.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the key or input is invalid.</exception>
    public static async Task<string> Encrypt(string plainText, string publicKeyPath)
    {
        try
        {
            ValidationHelper.ValidateRequired(plainText, nameof(plainText));
            ValidationHelper.ValidateRequired(publicKeyPath, nameof(publicKeyPath));

            string publicKey = File.ReadAllText(publicKeyPath);
            ValidationHelper.ValidateRequired(publicKey, nameof(publicKey));

            string encryptedText = await pgpEncryptionService.EncryptText(plainText, publicKey);

            return encryptedText;
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred during encryption", ex);
        }
    }

    /// <summary>
    /// Reads a credential from the Windows Credential Manager using a given name and optional username.
    /// </summary>
    /// <param name="name">The credential name.</param>
    /// <param name="username">The expected username (optional).</param>
    /// <returns>The matching credential object.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the credential is not found or invalid.</exception>
    public static Credential ReadCredential(string name, string username)
    {
        try
        {
            ValidationHelper.ValidateRequired(name, nameof(name));
            return wcmService.ReadCredential(name, username);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred reading the credentials", ex);
        }
    }

    /// <summary>
    /// Creates or updates a credential entry in the Windows Credential Manager.
    /// If the secret exceeds the maximum allowed length, it is automatically fragmented.
    /// </summary>
    /// <param name="name">The name of the credential.</param>
    /// <param name="username">The username associated with the credential.</param>
    /// <param name="secret">The secret or password to store.</param>
    /// <exception cref="InvalidOperationException">Thrown if the creation fails or input is invalid.</exception>
    public static void CreateCredential(string name, string username, string secret)
    {
        try
        {
            ValidationHelper.ValidateRequired(name, nameof(name));
            ValidationHelper.ValidateRequired(secret, nameof(secret));

            wcmService.CreateCredential(name, username, secret);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred creating the credentials", ex);
        }
    }

    /// <summary>
    /// Retrieves a secret value from Azure Key Vault using the specified URI and key name.
    /// </summary>
    /// <param name="keyVaultUri">The full URI to the Azure Key Vault.</param>
    /// <param name="key">The name of the secret to retrieve.</param>
    /// <returns>The retrieved secret value as a string.</returns>
    /// <exception cref="InvalidOperationException">Thrown if retrieval fails or input is invalid.</exception>
    public static async Task<string> GetAKVaultAsync(string keyVaultUri, string key)
    {
        try
        {
            ValidationHelper.ValidateRequired(keyVaultUri, nameof(keyVaultUri));
            ValidationHelper.ValidateRequired(key, nameof(key));

            return await akvService.GetAKVaultAsync(keyVaultUri, key);
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException("An error occurred getting key vault.", ex);
        }
    }
}


/// <summary>
/// Defines application-wide constant values used for PGP key retrieval and credential handling.
/// </summary>
internal static class Constants

/// <summary>
/// Represents a credential stored or retrieved from the Windows Credential Manager.
/// Includes a name (target), username, and password or secret.
/// </summary>
public class Credential



/// <summary>
/// Service class for performing PGP encryption and decryption operations.
/// Uses public and private key pairs with optional passphrases for secure data handling.
/// </summary>
internal class PGPEncryptionService
{
    /// <summary>
    /// Encrypts the provided plain text using a PGP public key.
    /// </summary>
    /// <param name="textToEncrypt">The plain text content to encrypt.</param>
    /// <param name="publicKey">The PGP public key used for encryption (in ASCII-armored format).</param>
    /// <returns>The encrypted text as a string (typically ASCII-armored).</returns>
    public async Task<string> EncryptText(string textToEncrypt, string publicKey)
    {

    }

    /// <summary>
    /// Decrypts the provided encrypted text using a PGP private key and passphrase.
    /// </summary>
    /// <param name="encryptedText">The encrypted content to decrypt (ASCII-armored PGP data).</param>
    /// <param name="privateKey">The PGP private key used for decryption (in ASCII-armored format).</param>
    /// <param name="passphrase">The passphrase associated with the private key.</param>
    /// <returns>The decrypted plain text content.</returns>
    public async Task<string> DecryptText(string encryptedText, string privateKey, string passphrase)
    {

    }
}



/// <summary>
/// Service class responsible for reading, writing, and managing credentials
/// in the Windows Credential Manager (WCM).
/// 
/// Supports both standard and fragmented credentials (split due to size limits).
/// Uses the CredentialManager API to interact with system-level secrets.
/// </summary>
internal class WCMService
{
    /// <summary>
    /// Reads a credential from Windows Credential Manager by name and (optionally) username.
    /// Throws an exception if not found or if the username does not match.
    /// </summary>
    /// <param name="name">The name/key of the credential.</param>
    /// <param name="username">Optional expected username to validate.</param>
    /// <returns>The retrieved credential.</returns>
    public Credential ReadCredential(string name, string username)
    {
        
    }

    /// <summary>
    /// Reads a fragmented credential composed of multiple parts (due to size limitations).
    /// The parts are expected to follow a naming convention: {name}_PART_{index}.
    /// </summary>
    /// <param name="name">The logical name of the full credential (without _PART_ suffix).</param>
    /// <returns>The reassembled credential.</returns>
    public Credential ReadFragmentedCredential(string name)
    {
       
    }

    /// <summary>
    /// Creates a credential in Windows Credential Manager.
    /// If the secret exceeds the allowed length, it is automatically split and stored as fragments.
    /// </summary>
    /// <param name="name">The base name/key of the credential.</param>
    /// <param name="userName">The username associated with the credential.</param>
    /// <param name="secret">The secret or password to store.</param>
    public void CreateCredential(string name, string userName, string secret)
    {
       
    }

    /// <summary>
/// Writes a single credential entry to Windows Credential Manager.
/// This method uses the provided credential name, username, and secret to create or update
/// an entry in the system's secure credential store.
/// </summary>
/// <param name="name">The unique name of the credential entry.</param>
/// <param name="userName">The username associated with the credential.</param>
/// <param name="secret">The secret (e.g., password, token) to store securely.</param>
private void WriteCredential(string name, string userName, string secret)
{

}


    /// <summary>
    /// Splits a long secret into multiple parts to bypass WCM size limitations.
    /// Each fragment is named using the format {name}_PART_{index}.
    /// </summary>
    /// <param name="name">The base name of the credential.</param>
    /// <param name="secret">The full secret to be split.</param>
    /// <returns>A dictionary of fragment names and corresponding secret parts.</returns>
    private Dictionary<string, string> BuildPartitionedLongCredential(string name, string secret)
    {
     
    }
}



/// <summary>
/// Provides a method to retrieve secrets from Azure Key Vault using a specified key and vault URI.
/// This class uses the Azure SDK with `DefaultAzureCredential` for authentication,
/// and allows proxy-aware HTTP communication for enterprise environments.
/// </summary>
internal class AKVService
{
    /// <summary>
    /// Asynchronously retrieves a secret value from Azure Key Vault.
    /// </summary>
    /// <param name="keyUri">The URI of the Azure Key Vault (e.g., https://myvault.vault.azure.net/).</param>
    /// <param name="key">The name of the secret to retrieve.</param>
    /// <returns>The value of the requested secret.</returns>
    /// <exception cref="InvalidOperationException">
    /// Thrown if the secret is not found or has no value.
    /// </exception>
    public async Task<string> GetAKVaultAsync(string keyUri, string key)


## Dependencies

| NuGet Package                                      | Version | Description                                     |
|---------------------------------------------------|---------|-------------------------------------------------|
| Microsoft.Owin.Host.SystemWeb                     | 4.2.2   | Enables OWIN integration in System.Web apps     |
| Microsoft.Owin.Security                           | 4.2.2   | Base middleware for authentication              |
| Microsoft.Owin.Security.Cookies                   | 4.2.2   | Cookie-based authentication support             |
| Microsoft.Owin.Security.OpenIdConnect             | 4.2.2   | OIDC protocol integration for OWIN              |
| Microsoft.IdentityModel.Protocols                 | 5.3.0   | Support for reading OIDC metadata               |
| Microsoft.IdentityModel.Protocols.OpenIdConnect   | 5.3.0   | OIDC protocol helpers for token validation      |
| Microsoft.IdentityModel.Tokens                    | 8.8.0   | Token validation and cryptographic support      |
| System.IdentityModel.Tokens.Jwt                   | 8.8.0   | Parsing and decoding JWTs (used by TokenHelper) |


## How It Works

### 1. Page Authentication

Inherit from `AuthPage` in your `.aspx.cs` code-behind:

```csharp
public partial class Dashboard : AuthPage
{
    protected void Page_Load(object sender, EventArgs e)
    {
        var userInfo = this.TokenEmpInfo;
        if (userInfo != null)
        {
            welcomeLabel.Text = $"Welcome, {userInfo.GivenName}";
        }
    }
}

## Library Structure

| Component      | Purpose                                                              |
|----------------|----------------------------------------------------------------------|
| `AuthPage`     | Base page that handles WAM redirect and token validation.            |
| `TokenEmpInfo` | Model for storing authenticated user's identity information.         |
| `TokenHelper`  | Utility class for checking authentication and reading token claims.  |

---

## Limitations

- Designed specifically for **ASP.NET Web Forms (.aspx)** applications using **OWIN-based authentication**.
- Assumes `id.token` and `access.token` have been added to claims during the `SecurityTokenValidated` event (usually handled in the application's OWIN configuration).




# AspOwinOAuthLib

## Overview

**AspOwinOAuthLib** is a lightweight utility library for **ASP.NET Web Forms (.NET Framework 4.7.2)** that provides a base class for `.aspx` pages to **enforce authentication early in the page lifecycle**.

The library integrates with an existing **OWIN-based authentication setup**, but does **not depend on OwinOAuthLib** or any specific OAuth configuration library.  
Its only purpose is to **override `Page.OnInit`**, ensuring that unauthenticated users are redirected to the login flow (e.g., WAM), and that the authentication context is validated before any page logic is executed.

## Key Features

- Reusable base class `AuthPage` for `.aspx` code-behind files.
- Forces OAuth authentication at `OnInit`, before controls or logic are loaded.
- Redirects unauthenticated users to WAM using `Authentication.Challenge`.
- Allows dynamic control of the post-authentication redirect URI via `HttpContext.Items`.
- Extracts identity information (like the `sub` claim) from the token and stores it in `TokenEmpInfo`.
- Includes a `TokenHelper` utility for accessing token data safely.

## Target Framework

- .NET Framework 4.7.2 (ASP.NET Web Forms)

## Installation

Include the library project in your solution or add the DLL to your Web Forms application.

### Required NuGet Packages

These must be installed in the consuming application (not in this library):

```xml
<PackageReference Include="Microsoft.Owin" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Host.SystemWeb" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.Cookies" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.OpenIdConnect" Version="4.2.2" />


# AspOwinOAuthLib

## Overview

**AspOwinOAuthLib** is a helper library for ASP.NET Web Forms applications (.NET Framework 4.7.2) that integrates with the OWIN OAuth/OIDC authentication pipeline to manage user login redirection and token-based identity extraction.

It complements `OwinOAuthLib` by handling redirect challenges to WAM (Web Access Manager), and provides utility methods and base classes to simplify authentication enforcement and user context management within Web Forms (`.aspx`) pages.

## Key Features

- Provides a reusable `AuthPage` base class that enforces authentication on every page request.
- Manages dynamic WAM redirect URIs via `HttpContext.Items`.
- Extracts and decodes claims from the ID token after successful authentication.
- Provides a `TokenHelper` utility for access token and ID token validation.
- Defines the `TokenEmpInfo` model to represent user identity information.
- Supports safe access to authentication context without static state.

## Target Framework

- .NET Framework 4.7.2 (Web Forms)

## Typical Use Case

You can use this library in ASP.NET Web Forms applications that need to:

- Redirect unauthenticated users to WAM via OWIN.
- Read the authenticated user's identity from the decoded ID token.
- Store identity info in a safe, per-request or per-session context (`TokenEmpInfo`).
- Avoid writing authentication logic manually in every `.aspx` page.

## Installation

Include the library project in your solution or add the DLL to your Web Forms application.

### Dependencies

The following packages must be installed in the consuming application:

```xml
<PackageReference Include="Microsoft.Owin" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Host.SystemWeb" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.Cookies" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.OpenIdConnect" Version="4.2.2" />



/// <summary>
/// Helper class for working with OAuth/OpenID Connect tokens and authentication state.
/// Provides methods to access the ID token and access token, validate authentication,
/// and extract claims from the decoded ID token.
/// </summary>
public static class TokenHelper
{
    /// <summary>
    /// Retrieves the raw ID token from the authenticated user's claims.
    /// Returns null if the user is not authenticated.
    /// </summary>
    /// <returns>The ID token as a string, or null if not available.</returns>
    private static string GetIdToken()
    {
        if (!IsUserAuthenticated()) return null;

        var identity = HttpContext.Current.GetOwinContext().Authentication.User.Identity as ClaimsIdentity;
        return identity?.FindFirst("id.token")?.Value;
    }

    /// <summary>
    /// Retrieves the raw access token from the authenticated user's claims.
    /// Returns null if the user is not authenticated.
    /// </summary>
    /// <returns>The access token as a string, or null if not available.</returns>
    private static string GetAccessToken()
    {
        if (!IsUserAuthenticated()) return null;

        var identity = HttpContext.Current.GetOwinContext().Authentication.User.Identity as ClaimsIdentity;
        return identity?.FindFirst("access.token")?.Value;
    }

    /// <summary>
    /// Checks if the current user is authenticated.
    /// </summary>
    /// <returns>True if the user is authenticated, false otherwise.</returns>
    public static bool IsUserAuthenticated()
    {
        return HttpContext.Current.GetOwinContext().Authentication.User.Identity.IsAuthenticated;
    }

    /// <summary>
    /// Checks if the current authenticated user has a valid ID token.
    /// </summary>
    /// <returns>True if a non-empty ID token is available, false otherwise.</returns>
    public static bool HasValidIdToken()
    {
        return !string.IsNullOrEmpty(GetIdToken());
    }

    /// <summary>
    /// Checks if the current authenticated user has a valid access token.
    /// </summary>
    /// <returns>True if a non-empty access token is available, false otherwise.</returns>
    public static bool HasValidAccessToken()
    {
        return !string.IsNullOrEmpty(GetAccessToken());
    }

    /// <summary>
    /// Extracts the value of a specific claim from the decoded ID token.
    /// </summary>
    /// <param name="claimType">The name/type of the claim to extract.</param>
    /// <returns>The value of the claim, or null if not found or token is missing.</returns>
    private static string GetClaimFromIdToken(string claimType)
    {
        string idToken = GetIdToken();

        if (string.IsNullOrEmpty(idToken))
            return null;

        var handler = new JwtSecurityTokenHandler();
        var token = handler.ReadJwtToken(idToken);

        return token.Claims.FirstOrDefault(c => c.Type == claimType)?.Value;
    }

    /// <summary>
    /// Extracts the "sub" (subject) claim from the decoded ID token.
    /// This is typically the unique identifier of the user.
    /// </summary>
    /// <returns>The value of the "sub" claim, or null if not found.</returns>
    public static string GetSub()
    {
        return GetClaimFromIdToken("sub");
    }
}


/// <summary>
/// Represents the authenticated user's identity information extracted from the ID token
/// in an OAuth/OpenID Connect authentication flow.
/// 
/// This class is typically populated after successful login via WAM (Web Access Manager),
/// and contains selected claims used across the application to identify the user.
/// </summary>

/// <summary>
/// Base class for ASP.NET Web Forms pages that enforces OAuth authentication
/// and manages user identity information obtained from the ID token.
/// 
/// This class checks if the user is authenticated during the page lifecycle (`OnInit`).
/// If the user has a valid token, it populates the `TokenEmpInfo` object with the subject (`sub`).
/// Otherwise, it redirects the user to WAM (Web Access Manager) using the OWIN authentication pipeline.
/// 
/// A custom redirect URI is dynamically retrieved from `HttpContext.Items["CustomRedirectUri"]`
/// to support multi-tenant or path-specific authentication flows.
/// </summary>
public class AuthPage : System.Web.UI.Page
{
    /// <summary>
    /// The redirect URI to be used for WAM authentication.
    /// This is typically determined dynamically based on the request context.
    /// </summary>
    public string redirectUri;

    /// <summary>
    /// Represents the current authenticated user's identity, populated from token claims.
    /// This object is initialized during OnInit after a successful authentication check.
    /// </summary>
    public TokenEmpInfo TokenEmpInfo { get; set; }

    /// <summary>
    /// Handles the page initialization lifecycle event.
    /// If the user is authenticated and a valid ID token is present, the user info is loaded into TokenEmpInfo.
    /// Otherwise, redirects the user to the WAM authentication flow.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected override void OnInit(EventArgs e)
    {
        try
        {
            if (TokenHelper.IsUserAuthenticated())
            {
                if (TokenHelper.HasValidIdToken())
                {
                    TokenEmpInfo = new TokenEmpInfo();
                    TokenEmpInfo.Sub = TokenHelper.GetSub();
                    base.OnInit(e);
                    return;
                }
                else
                {
                    throw new Exception("Missing Token");
                }
            }
            else
            {
                RedirectToWAM();
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }
    }

    /// <summary>
    /// Handles the page load lifecycle event.
    /// Ensures authentication has occurred before continuing the load process.
    /// </summary>
    /// <param name="e">Event arguments.</param>
    protected override void OnLoad(EventArgs e)
    {
        if (TokenHelper.IsUserAuthenticated())
        {
            base.OnLoad(e);
        }
    }

    /// <summary>
    /// Redirects the user to the Web Access Manager (WAM) for authentication using OWIN's challenge flow.
    /// Retrieves the redirect URI from HttpContext.Items["CustomRedirectUri"].
    /// Throws an error if the redirect URI is not set.
    /// </summary>
    public void RedirectToWAM()
    {
        try
        {
            var httpContext = HttpContext.Current;
            redirectUri = httpContext?.Items["CustomRedirectUri"] as string;

            if (string.IsNullOrEmpty(redirectUri))
            {
                throw new InvalidOperationException("Missing redirectUri");
            }

            HttpContext.Current.GetOwinContext().Authentication.Challenge(
                new AuthenticationProperties
                {
                    RedirectUri = redirectUri,
                    AllowRefresh = true,
                    IsPersistent = true
                },
                OpenIdConnectAuthenticationDefaults.AuthenticationType
            );

            HttpContext.Current.Response.StatusCode = 401;
            HttpContext.Current.ApplicationInstance.CompleteRequest();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(ex.Message);
        }
    }
}



/// <summary>
/// Provides a static context to store user identity information (claims) extracted from the ID token
/// during the OpenID Connect authentication flow.
/// 
/// This information is typically populated after successful authentication and is used across the application
/// to identify the logged-in employee and personalize the user experience.
/// </summary>


/// <summary>
/// Redirects the current request to the Web Access Manager (WAM) login endpoint.
/// Uses OWIN‚Äôs `Authentication.Challenge` method to initiate the authentication flow.
/// 
/// Retrieves the redirect URI from the current HTTP context's `Items` collection using the key "CustomRedirectUri".
/// This value is typically set earlier in the request lifecycle (for example, during `Application_BeginRequest` or overridden in OnInit)
/// to dynamically control which URL the user should return to after authentication.
/// 
/// Throws an exception if the redirect URI is missing or an error occurs during redirection.
/// </summary>
/// <exception cref="InvalidOperationException">Thrown if redirectUri is missing or an error occurs during redirection.</exception>
public void RedirectToWAM()
{
    try
    {
        var httpContext = HttpContext.Current;
        // Retrieves a dynamically set redirect URI for this request, allowing multi-tenant or multi-path flexibility.
        redirectUri = httpContext?.Items["CustomRedirectUri"] as string;

        if (string.IsNullOrEmpty(redirectUri))
        {
            throw new InvalidOperationException("Missing redirectUri");
        }

        HttpContext.Current.GetOwinContext().Authentication.Challenge(
            new AuthenticationProperties
            {
                RedirectUri = redirectUri,
                AllowRefresh = true,
                IsPersistent = true
            },
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );

        HttpContext.Current.Response.StatusCode = 401;
        HttpContext.Current.ApplicationInstance.CompleteRequest();
    }
    catch (Exception ex)
    {
        throw new InvalidOperationException(ex.Message);
    }
}



/// <summary>
/// Base page class for ASP.NET Web Forms that handles OAuth authentication via WAM (Web Access Manager).
/// 
/// This class intercepts the initialization and loading of the page to ensure the user is authenticated.
/// If the user is not authenticated or lacks a valid ID token, they are redirected to WAM using OWIN middleware.
/// 
/// Extracts the `sub` (subject) claim from the ID token and stores it in a shared token context (`TokenEmpinfo.Sub`).
/// </summary>
public class AuthPage : System.Web.UI.Page
{
    /// <summary>
    /// Stores the redirect URI used for WAM authentication.
    /// This is typically set during the request lifecycle and passed to OWIN's Challenge call.
    /// </summary>
    public string redirectUri;

    /// <summary>
    /// Overrides the page's initialization logic to check for authentication.
    /// If the user has a valid ID token, extracts the subject (`sub`) and continues initialization.
    /// Otherwise, initiates a redirect to WAM.
    /// </summary>
    /// <param name="e">Standard EventArgs for page lifecycle.</param>
    protected override void OnInit(EventArgs e)
    {
        try
        {
            if (TokenHelper.IsUserAuthenticated())
            {
                if (TokenHelper.HasValidIdToken())
                {
                    TokenEmpinfo.Sub = TokenHelper.GetSub();
                    base.OnInit(e);
                    return;
                }
                else
                {
                    throw new Exception("Missing Token");
                }
            }
            else
            {
                RedirectToWAM();
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }
    }

    /// <summary>
    /// Optionally processes logic during page load. Placeholder for further customization.
    /// Still calls base implementation to preserve normal page lifecycle behavior.
    /// </summary>
    /// <param name="e">Standard EventArgs for page lifecycle.</param>
    protected override void OnLoad(EventArgs e)
    {
        if (TokenHelper.IsUserAuthenticated())
        {
            // Additional logic can be added here if needed
        }

        base.OnLoad(e);
    }

    /// <summary>
    /// Redirects the current request to the Web Access Manager (WAM) login endpoint.
    /// Uses OWIN‚Äôs `Authentication.Challenge` method to initiate the authentication flow.
    /// </summary>
    /// <exception cref="InvalidOperationException">Thrown if redirectUri is missing or an error occurs during redirection.</exception>
    public void RedirectToWAM()
    {
        try
        {
            var httpContext = HttpContext.Current;
            redirectUri = httpContext?.Items["CustomRedirectUri"] as string;

            if (string.IsNullOrEmpty(redirectUri))
            {
                throw new InvalidOperationException("Missing redirectUri");
            }

            HttpContext.Current.GetOwinContext().Authentication.Challenge(
                new AuthenticationProperties
                {
                    RedirectUri = redirectUri,
                    AllowRefresh = true,
                    IsPersistent = true
                },
                OpenIdConnectAuthenticationDefaults.AuthenticationType
            );

            HttpContext.Current.Response.StatusCode = 401;
            HttpContext.Current.ApplicationInstance.CompleteRequest();
        }
        catch (Exception ex)
        {
            throw new InvalidOperationException(ex.Message);
        }
    }
}





# OwinOAuthLib

## Overview

**OwinOAuthLib** is a .NET Standard 2.0 library designed to simplify the configuration of **OAuth 2.0** and **OpenID Connect (OIDC)** authentication for ASP.NET applications using **OWIN**.  
It provides a clean abstraction to configure authentication middleware, manage cookie-based authentication, and handle key OpenID Connect events, including token validation and error handling.

This library is intended for applications running **.NET Framework 4.7.2** with OWIN-based middleware.

## Key Features

- Simplifies OAuth 2.0 / OIDC configuration for OWIN.
- Sets up **cookie-based authentication**.
- Automatically registers OpenID Connect event handlers:
  - Redirect to identity provider.
  - Security token validated.
  - Authentication failed.
- Exposes an event override for `RedirectToIdentityProvider`.
- Provides centralized storage for authentication properties (`AuthProperties`).
- Performs required parameter validation to prevent misconfiguration.

## Target Framework

- .NET Standard 2.0

## Typical Use Case

The library is used in **ASP.NET Web Forms** or **ASP.NET MVC** applications (.NET Framework 4.7.2) that require secure authentication with:
- **OpenID Connect** providers.
- **Web Access Manager (WAM)** integrations.

It streamlines setting up the OWIN pipeline without repetitive boilerplate code.

## Installation

Add a reference to the `OwinOAuthLib` project or include it as a library in your solution.

Install the following NuGet packages in the consuming application:

```xml
<PackageReference Include="Microsoft.Owin" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Host.SystemWeb" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.Cookies" Version="4.2.2" />
<PackageReference Include="Microsoft.Owin.Security.OpenIdConnect" Version="4.2.2" />

## Configuration Example

In your application‚Äôs `Startup.cs` or `Startup.Auth.cs`:

```csharp
using OwinOAuthLib;

public void Configuration(IAppBuilder app)
{
    AuthConfig.ConfigureAuth(
        app,
        ClientId: "your-client-id",
        ClientSecret: "your-client-secret",
        BaseUrl: "https://your-authority.com",
        RedirectUri: "https://your-app.com/signin-oidc"
    );
}

## How It Works

### Validation
All required OAuth parameters (`ClientId`, `ClientSecret`, `BaseUrl`, `RedirectUri`) are validated at startup.

### Cookie Authentication
Registers OWIN‚Äôs `CookieAuthenticationOptions` for session management.

### OpenID Connect Authentication
Registers OWIN‚Äôs `OpenIdConnectAuthenticationOptions` with:

- **ResponseType** set to `CodeIdToken`.
- **Scope** includes `openid` and `profile`.
- Standard notification handlers:
  - `RedirectToIdentityProvider`
  - `SecurityTokenValidated`
  - `AuthenticationFailed`

### Token Claims
Adds the **ID token** and **Access token** as claims to the authenticated user‚Äôs identity for later use.

### Override Support
If needed, the `OwinEvents.OnRedirectToIdentityProviderOverride` delegate can be assigned in the application to customize the redirect URI logic dynamically.

## Library Structure

| Class            | Purpose                                                   |
|------------------|-----------------------------------------------------------|
| `AuthConfig`     | Configures OWIN authentication pipeline.                  |
| `AuthProperties` | Stores reusable authentication parameters.                |
| `OwinEvents`     | Provides an event hook for `RedirectToIdentityProvider`.  |
| `ValidationHelper` | Ensures required parameters are provided at runtime.     |

## Dependencies

| NuGet Package                          | Version |
|---------------------------------------|---------|
| Microsoft.Owin                         | 4.2.2   |
| Microsoft.Owin.Host.SystemWeb         | 4.2.2   |
| Microsoft.Owin.Security               | 4.2.2   |
| Microsoft.Owin.Security.Cookies       | 4.2.2   |
| Microsoft.Owin.Security.OpenIdConnect | 4.2.2   |

## Security Considerations

### Token Security
Tokens (**ID token** and **Access token**) are added as claims but should be handled carefully in downstream code to avoid logging or exposing sensitive information.

### Parameter Validation
The library enforces required parameter validation to prevent runtime errors caused by missing or misconfigured values.

## Limitations

- Designed for ASP.NET applications using **OWIN** middleware.
- Assumes the consuming application handles secure storage of client secrets and other sensitive values (recommended via Azure Key Vault or equivalent).



/// <summary>
/// Provides a mechanism to override the default behavior of the
/// RedirectToIdentityProvider event in the authentication flow.
/// </summary>
public static class OwinEvents
{
    /// <summary>
    /// Allows customization of the RedirectToIdentityProvider event by assigning a delegate.
    /// </summary>
    public static Func<RedirectToIdentityProviderNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions>, Task> OnRedirectToIdentityProviderOverride;
}


/// <summary>
/// Stores authentication properties such as client credentials, authority,
/// and redirect URIs. Used by the OAuth/OIDC configuration.
/// </summary>
public static class AuthProperties
{
    public static string ClientId { get; set; }
    public static string ClientSecret { get; set; }
    public static string BaseUrl { get; set; }
    public static string Authorize { get; set; }
    public static string RedirectUri { get; set; }
    public static string IdTokenEndpoint { get; set; }
    public static string PostLogoutRedirectUri { get; set; }
    public static int ExpireTimeSpan { get; set; }
}


/// <summary>
/// Provides validation methods to ensure required values are present.
/// </summary>
internal static class ValidationHelper
{
    /// <summary>
    /// Validates that a required string value is not null or whitespace.
    /// Throws an ArgumentException if validation fails.
/// </summary>
/// <param name="value">The value to validate.</param>
/// <param name="paramName">The name of the parameter being validated.</param>
/// <param name="errorMessage">Optional custom error message.</param>
    public static void ValidateRequired(string value, string paramName, string errorMessage = null)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new ArgumentException(errorMessage ?? $"Missing required field: {paramName}", paramName);
        }
    }
}



/// <summary>
/// Provides methods to configure OAuth and OpenID Connect authentication
/// for the OWIN middleware pipeline. Sets up cookie authentication and
/// OpenID Connect handlers with customizable events.
/// </summary>
public class AuthConfig
{
    /// <summary>
    /// Configures OAuth and OIDC authentication using the provided client credentials,
    /// base URL, and redirect URI. Sets up cookie authentication and OpenID Connect options,
    /// including event handlers for redirect, token validation, and authentication failures.
    /// </summary>
    /// <param name="app">The OWIN application builder.</param>
    /// <param name="ClientId">OAuth client identifier.</param>
    /// <param name="ClientSecret">OAuth client secret.</param>
    /// <param name="BaseUrl">The authority URL (WAM or identity provider base URL).</param>
    /// <param name="RedirectUri">The redirect URI for the authentication flow.</param>
    public static void ConfigureAuth(IAppBuilder app, string ClientId, string ClientSecret, string BaseUrl, string RedirectUri)
    {
        ValidationHelper.ValidateRequired(ClientId, nameof(ClientId));
        ValidationHelper.ValidateRequired(BaseUrl, nameof(BaseUrl));
        ValidationHelper.ValidateRequired(ClientSecret, nameof(ClientSecret));
        ValidationHelper.ValidateRequired(RedirectUri, nameof(RedirectUri));

        AuthProperties.ClientId = ClientId;
        AuthProperties.ClientSecret = ClientSecret;
        AuthProperties.BaseUrl = BaseUrl;
        AuthProperties.RedirectUri = RedirectUri;

        app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            CookieSameSite = SameSiteMode.None,
            CookieManager = new SystemWebCookieManager()
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = AuthProperties.ClientId,
            ClientSecret = AuthProperties.ClientSecret,
            Authority = AuthProperties.BaseUrl,
            RedirectUri = AuthProperties.RedirectUri,
            ResponseType = OpenIdConnectResponseType.CodeIdToken,
            Scope = "openid profile",
            CookieManager = new SystemWebCookieManager(),
            Notifications = new OpenIdConnectAuthenticationNotifications
            {
                RedirectToIdentityProvider = OnRedirectToIdentityProvider,
                SecurityTokenValidated = OnSecurityTokenValidated,
                AuthenticationFailed = OnAuthenticationFailed
            }
        });
    }

    /// <summary>
    /// Event handler for the redirect to the identity provider.
    /// Allows overriding the redirect URI dynamically if required.
    /// </summary>
    private static Task OnRedirectToIdentityProvider(RedirectToIdentityProviderNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions> context)
    {
        if (OwinEvents.OnRedirectToIdentityProviderOverride != null)
        {
            return OwinEvents.OnRedirectToIdentityProviderOverride.Invoke(context);
        }

        string redirectUri =
            context.OwinContext?.Authentication?.AuthenticationResponseChallenge?.Properties?.RedirectUri;

        if (!string.IsNullOrEmpty(redirectUri))
        {
            context.ProtocolMessage.RedirectUri = redirectUri;
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// Event handler triggered when the security token has been validated.
    /// Adds the ID token and access token as claims to the authenticated identity.
    /// </summary>
    private static Task OnSecurityTokenValidated(SecurityTokenValidatedNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions> context)
    {
        var idToken = context.ProtocolMessage.IdToken;
        var accessToken = context.ProtocolMessage.AccessToken;

        var claimsIdentity = context.AuthenticationTicket.Identity;

        if (!string.IsNullOrEmpty(idToken))
        {
            claimsIdentity.AddClaim(new System.Security.Claims.Claim("id.token", idToken));
        }

        if (!string.IsNullOrEmpty(accessToken))
        {
            claimsIdentity.AddClaim(new System.Security.Claims.Claim("access.token", accessToken));
        }

        return Task.CompletedTask;
    }

    /// <summary>
    /// Event handler triggered when authentication fails.
    /// Redirects the user to an error page with the exception message.
    /// </summary>
    private static async Task OnAuthenticationFailed(AuthenticationFailedNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions> context)
    {
        context.HandleResponse();
        context.Response.Redirect("/error?message=" + Uri.EscapeDataString(context.Exception.Message));
    }
}



### Required NuGet Libraries and Versions

The following libraries and versions are required for correct functionality:

| Library                                         | Version       |
|-------------------------------------------------|---------------|
| Microsoft.IdentityModel.Tokens                  | 8.8.0.0       |
| Microsoft.IdentityModel.Protocols.OpenIdConnect | 5.3.0.0       |
| BouncyCastle.Cryptography                       | 2.0.0.0       |
| BouncyCastle.Crypto                             | 1.8.9.0       |
| Microsoft.Owin                                  | 4.2.2.0       |
| Microsoft.Owin.Host.System.Web                  | 4.2.2.0       |
| Microsoft.Owin.Security                         | 4.2.2.0       |
| Microsoft.Owin.Security.Cookies                 | 4.2.2.0       |
| Microsoft.Owin.Security.OpenIdConnect           | 4.2.2.0       |
| Owin                                           | 1.0.0.0       |
| System.IdentityModel.Tokens.Jwt                 | 8.8.0.0       |
| System.Text.Json                                | 9.0.0.3       |
| Azure.Core                                     | 1.44.1.0      |
| Azure.Identity                                 | 1.13.2.0      |
| Azure.Security.KeyVault.Secrets                 | 4.7.0.0       |


# OAuth Authentication Implementation ‚Äî ASP.NET Web Forms (.NET Framework 4.7.2)

## Overview

This project implements **OAuth 2.0** authentication and **OpenID Connect (OIDC)** in an ASP.NET Web Forms application targeting **.NET Framework 4.7.2**.  
The solution authenticates users through a Web Access Manager (WAM) and leverages cookies to maintain authentication state. It also retrieves user data from an external HR API post-authentication.

## Key Features

- OAuth 2.0 / OIDC-based authentication.
- Cookie-based authentication for session management.
- Integration with **Web Access Manager (WAM)** for login and token acquisition.
- Secure retrieval of secrets from **Azure Key Vault (AKV)**.
- User data extraction from tokens.
- Retrieval of detailed employee information via HRAPI.
- Structured logging with **Serilog**.

## Versions & Libraries

| Component                    | Version                      | Notes |
|------------------------------|------------------------------|-------|
| .NET Framework               | 4.7.2                        |       |
| Owin                         | 4.2.2 (SystemWeb)            |       |
| OwinOAuth                    | .NET Standard 2.0            | OAuth/OIDC configuration |
| AspOwin                      | .NET Standard 2.0            | WAM redirection and user data extraction |
| CryptoPGP                    | .NET Standard 2.0            | Queries Azure Key Vault for secrets |
| HRAPILib                     | .NET Standard 2.0            | Retrieves employee information from HR API |
| Serilog                      | 2.x                          | Logging |

## Architectural Decisions

- **Cookie Authentication**  
  Chosen to manage session state in a way compatible with Web Forms and scalable for enterprise usage.

- **OwinOAuth Library**  
  Provides the abstraction for OAuth and OIDC setup, reusable across projects.

- **AspOwin Library**  
  Handles WAM redirection and extracts essential user data (claims) from the authentication token to support personalized and secure sessions.

- **CryptoPGP Library**  
  Retrieves sensitive configuration data (client IDs, secrets, private keys) securely from Azure Key Vault. Keeps secrets out of the application code and configuration files.

- **HRAPILib**  
  Queries the HRAPI to retrieve comprehensive employee information based on the authenticated user's identifier.

- **Serilog & Custom Logging Middleware**  
  Enables structured and consistent logging throughout the application for better traceability and troubleshooting.

## Authentication Flow Summary

1. **Unauthenticated Request**  
   User accesses a protected resource. The app triggers redirection to WAM using **AspOwin**.

2. **User Authentication via WAM**  
   The user logs in through WAM. Upon success, WAM redirects back to the application with an OAuth/OIDC token.

3. **Token Validation & Claim Extraction**  
   **OwinOAuth** validates the token. **AspOwin** extracts essential user data (claims) from the token payload.

4. **Authentication Cookie Creation**  
   A secure cookie is created to persist the authenticated session.

5. **User Data Retrieval from HRAPI**  
   The application calls **HRAPILib** to fetch full employee profile data using the user identifier extracted from the token.

6. **Session Continuation**  
   On subsequent requests, the authentication cookie is validated to maintain the user session without re-authentication.

## Folder Structure (Key Components)

```plaintext
/App_Start
    Startup.cs            // Configures OWIN, OAuth, and Serilog

/Helpers
    LogHelper.cs          // Structured logging helper

/Middleware
    LoggingMiddleware.cs  // Logs HTTP request/response data

/Security
    AuthConfig.cs         // OAuth and OIDC configuration

/Models
    EmpInfo.cs            // Employee profile model

/Libraries
    OwinOAuth (.NET Standard 2.0)
    AspOwin (.NET Standard 2.0)
    CryptoPGP (.NET Standard 2.0)
    HRAPILib (.NET Standard 2.0)



# OAuth Authentication Implementation ‚Äî ASP.NET Web Forms (.NET Framework 4.7.2)

## Overview

This project implements **OAuth 2.0** authentication and **OpenID Connect (OIDC)** in an ASP.NET Web Forms application targeting **.NET Framework 4.7.2**. The solution authenticates users through a Web Access Manager (WAM) and leverages cookies to manage authentication state throughout the application.

## Key Features

- OAuth 2.0 / OIDC-based authentication.
- Cookie-based authentication management.
- Integration with **Web Access Manager (WAM)** for user login and redirection.
- Secure storage of client credentials and secrets using **Azure Key Vault (AKV)**.
- Logging implemented via **Serilog** and a custom `LogHelper`.

## Versions & Libraries

| Component                    | Version                      |
|------------------------------|------------------------------|
| .NET Framework               | 4.7.2                        |
| Owin                         | 4.2.2 (hosted in SystemWeb) |
| OwinOAuth (custom library)   | .NET Standard 2.0           |
| AspOwin (custom library)     | .NET Standard 2.0           |
| Serilog                      | 2.x                          |

> **Note:** `OwinOAuth` handles the OAuth and OIDC authentication configuration.  
> `AspOwin` is responsible for managing the redirection to WAM during the login flow.

## Architectural Decisions

- **Cookie Authentication:**  
  Chosen to maintain user session and state post-authentication in a scalable and standard-compliant way compatible with ASP.NET Web Forms.

- **OwinOAuth Library:**  
  Created to abstract the complexity of configuring OAuth and OIDC in a reusable manner compatible with .NET Standard 2.0, easing integration in future apps.

- **AspOwin Library:**  
  Handles WAM-specific redirections, decoupling environment-specific login mechanisms from the main application code.

- **Azure Key Vault (AKV):**  
  Used to securely store client IDs, secrets, and cryptographic keys, minimizing sensitive data exposure in code and configuration files.

## Flow Summary

1. **Unauthenticated Request:**  
   When a user requests a protected resource, the app redirects them to WAM for authentication using `AspOwin`.

2. **WAM Authentication:**  
   The user logs in via WAM. Upon success, WAM redirects back to the app with tokens.

3. **Token Handling & Cookie Creation:**  
   `OwinOAuth` validates the token and creates an authentication cookie to persist the user session.

4. **Session Continuation:**  
   On subsequent requests, the authentication cookie is validated, allowing seamless session continuity without re-authentication.

## Folder Structure (Key Components)

```plaintext
/App_Start
    Startup.cs            // Configures OWIN, OAuth, and Serilog

/Helpers
    LogHelper.cs          // Structured logging helper

/Middleware
    LoggingMiddleware.cs  // Logs incoming and outgoing HTTP traffic

/Security
    AuthConfig.cs         // OAuth and OIDC configuration

/Models
    EmpInfo.cs            // Employee profile model




/// <summary>
/// Determines the language code based on the employee's preferred language string.
/// Supports recognition of "English", "en_US", "French", and "fr_FR".
/// Defaults to English ("en") if the preferred language is null, empty, or unrecognized.
/// </summary>
/// <param name="EmpPreferredLanguage">The preferred language string from the employee profile.</param>
/// <returns>
/// A language code string: "en" for English or "fr" for French.
/// </returns>




/// <summary>
/// Initializes the page and determines the appropriate authentication redirect URI based on the incoming request's host and path.
/// Evaluates headers and URL patterns to select the correct WAM (Web Access Manager) endpoint for the authentication flow.
/// If no valid redirect URI is found, writes an error message and terminates the response.
/// 
/// The selected redirect URI is stored in the current HTTP context items collection under the key "CustomRedirectUri".
/// </summary>
/// <param name="e">Event arguments associated with the OnInit event.</param>



/// <summary>
/// Represents the basic employee information retrieved from HRAPI or the database.
/// This class contains profile details for the employee who has logged into the application.
/// </summary>


/// <summary>
/// Provides access to secret configuration values stored in Azure Key Vault (AKV).
/// Implements lazy initialization to ensure secrets are loaded only once and on demand.
/// 
/// Secrets retrieved include:
/// - Client IDs and secrets for HRAPI and WAM authentication flows
/// - The HRAPI private key in PEM format
/// 
/// Secrets are retrieved via CryptoManager and decoded if necessary (e.g., PEM key in Base64).
/// Logging is used to trace secret loading operations and detect failures.
/// </summary>


/// <summary>
/// Custom OWIN middleware that logs incoming HTTP requests and outgoing HTTP responses.
/// Captures method, URI, headers, and response status for troubleshooting and auditing purposes.
/// Uses a structured logging helper (LogHelper) to record debug-level logs.
/// </summary>

    /// <summary>
    /// Initializes a new instance of the <see cref="LoggingMiddleware"/> class.
    /// </summary>
    /// <param name="next">The next middleware component in the OWIN pipeline.</param>




    /// <summary>
    /// Processes an incoming HTTP request and an outgoing HTTP response.
    /// Logs request method, URI, request headers, response status code, and response headers.
    /// </summary>
    /// <param name="context">The OWIN context containing the HTTP request and response information.</param>
    /// <returns>A task that represents the asynchronous operation.</returns>





/// <summary>
/// Provides a helper utility for structured logging using Serilog.
/// Defines log levels and formats log messages consistently across the application.
/// </summary>



    /// <summary>
    /// Defines the available log severity levels for application logging.
    /// </summary>



    /// <summary>
    /// Logs a formatted message to Serilog based on the specified log level.
    /// The message includes optional environment and identifier information for better traceability.
    /// </summary>
    /// <param name="message">The main log message to be recorded.</param>
    /// <param name="environment">Optional. The environment or context where the log is generated (e.g., Development, Production).</param>
    /// <param name="id">Optional. An identifier associated with the log entry, such as a request ID or operation ID.</param>
    /// <param name="level">The severity level of the log. Defaults to Informational if not specified.</param>



/// <summary>
/// Retrieves basic employee information from the database based on the provided employee ID (empid).
/// Connects to the appropriate environment-specific database, executes a query against the LWS_Emp_Basic table,
/// and maps selected fields into an <see cref="Empinfo"/> object.
/// 
/// In case of a database connection or query error, writes an error message to the response and terminates the request.
/// </summary>
/// <param name="empid">The employee ID (ScotiaID) used to search for the employee's information in the database.</param>
/// <returns>
/// An <see cref="Empinfo"/> object containing selected employee details, or null if no record is found or an error occurs.
/// </returns>


/// <summary>
/// Validates that the employee token (TokenEmpinfo) contains the required employee identifier (Sub).
/// If the identifier is missing, sends an error message to the client and terminates the response.
/// </summary>


/// <summary>
/// Validates that the retrieved employee information from HRAPI is not null and contains a valid employee number.
/// If validation fails, sends an error message to the client and terminates the response.
/// </summary>
/// <param name="empinfo">The employee information response object to validate.</param>

/// <summary>
/// Determines the language code based on the employee's preferred language.
/// Defaults to English if the preferred language is not set or unrecognized.
/// </summary>
/// <param name="empPreferredLanguage">The employee's preferred language as a string.</param>
/// <returns>
/// A language code string (e.g., "en" for English or "fr" for French).
/// </returns>


/// <summary>
/// Retrieves employee information from the HRAPI service.
/// 
/// Initializes and configures HRAPI client properties from AppSettings and Azure Key Vault.
/// Validates the access token before making the API call and ensures the received employee data is valid.
/// 
/// In case of any failure during the process, logs the error and returns a user-friendly message
/// to the client, terminating the response.
/// </summary>
/// <returns>
/// An <see cref="EmpinfoHRApiResponse"/> object containing the employee information,
/// or null if an error occurs.
/// </returns>


/// <summary>
/// Handles the BeginRequest event for each incoming HTTP request.
/// Based on the request URL, dynamically updates the authentication redirect URI
/// used in the OAuth/OpenID Connect flow to point to the correct WAM (Web Access Manager) endpoint.
/// 
/// Reads route prefixes and redirect URIs from AppSettings configuration.
/// This logic ensures the application redirects users to the appropriate authentication flow
/// depending on the access path (e.g., HR Passport or Scotiaworld).
/// </summary>
/// <param name="sender">The source of the event.</param>
/// <param name="e">The EventArgs instance containing the event data.</param>
protected void Application_BeginRequest(object sender, EventArgs e)
{
    var context = HttpContext.Current;
    string path = context?.Request?.Url?.ToString();

    if (path != null)
    {
        string appRoutePrefixHRPassport = ConfigurationManager.AppSettings["AppRoute_Prefix_HRPassport"];
        string appRoutePrefixScotiaworld = ConfigurationManager.AppSettings["AppRoute_Prefix_Scotiaworld"];
        string wamRedirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];
        string wamScotiaWorldRedirectUri = ConfigurationManager.AppSettings["WamScotiaWorldRedirectUri"];

        if (path.Contains(appRoutePrefixHRPassport))
        {
            AuthProperties.RedirectUri = wamRedirectUri;
        }
        else if (path.Contains(appRoutePrefixScotiaworld))
        {
            AuthProperties.RedirectUri = wamScotiaWorldRedirectUri;
        }
    }
}


/// <summary>
    /// Startup class responsible for configuring the authentication pipeline for the application.
    /// Initializes logging, retrieves configuration values, fetches secrets from Azure Key Vault,
    /// and sets up OAuth and OpenID Connect authentication by redirecting users to WAM (Web Access Manager).
    /// </summary>


/// <summary>
        /// Configures the OWIN middleware pipeline.
        /// This includes setting up Serilog for logging, fetching authentication secrets from Key Vault,
        /// and configuring OAuth/OIDC authentication through the external WAM provider.
        /// 
        /// It uses ASP.NET OWIN libraries to implement cookie-based authentication as part of the OAuth/OpenID Connect flow.
        /// </summary>
        /// <param name="app">The OWIN application builder used to configure middleware components.</param>
