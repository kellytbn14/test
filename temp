<configuration>
  <appSettings>
    <!-- 5pm EST del 19/11/2025 es 22:00 UTC -->
    <add key="EventDateUtc" value="2025-11-19T22:00:00Z" />
    <add key="EventTimeZoneId" value="Eastern Standard Time" />
  </appSettings>

  <system.web>
    <globalization culture="auto" uiCulture="auto" enableClientBasedCulture="true" />
  </system.web>
</configuration>


using System;
using System.Configuration;
using System.Globalization;

public static class DateLocalizationHelper
{
  private static (string en, string fr) GetZoneAbbreviation(string tzId, bool isDst)
{
    switch (tzId)
    {
        case "Eastern Standard Time":
            return (isDst ? "EDT" : "EST", "HE"); // Heure de l'Est
        case "Central Standard Time":
            return (isDst ? "CDT" : "CST", "HC"); // Heure du Centre
        case "Mountain Standard Time":
            return (isDst ? "MDT" : "MST", "HR"); // Heure des Rocheuses
        case "Pacific Standard Time":
            return (isDst ? "PDT" : "PST", "HP"); // Heure du Pacifique
        default:
            return ("", ""); // fallback
    }
}

public static string FormatEventDateForUi(CultureInfo uiCulture)
{
    var rawUtc = ConfigurationManager.AppSettings["EventDateUtc"];
    var tzId   = ConfigurationManager.AppSettings["EventTimeZoneId"] ?? "Eastern Standard Time";

    if (!DateTime.TryParse(rawUtc, CultureInfo.InvariantCulture, 
        DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out var eventUtc))
        throw new FormatException($"Invalid UTC datetime in config: {rawUtc}");

    var tz   = TimeZoneInfo.FindSystemTimeZoneById(tzId);
    var local = TimeZoneInfo.ConvertTimeFromUtc(eventUtc, tz);
    var isDst = tz.IsDaylightSavingTime(local);

    var (tzEn, tzFr) = GetZoneAbbreviation(tzId, isDst);

    var lang = uiCulture.TwoLetterISOLanguageName;

    if (lang == "fr")
    {
        // 17h (HE) le 19 novembre, 2025
        var time = $"{local:HH}h";
        var date = local.ToString("d MMMM, yyyy", uiCulture).ToLower(uiCulture);
        return $"{time} ({tzFr}) le {date}";
    }
    else
    {
        // 5pm EST on November 19, 2025.
        var hour = local.ToString("h", CultureInfo.InvariantCulture);
        var ampm = local.ToString("tt", CultureInfo.GetCultureInfo("en-US")).ToLowerInvariant();
        var date = local.ToString("MMMM d, yyyy", CultureInfo.GetCultureInfo("en-US"));
        return $"{hour}{ampm} {tzEn} on {date}.";
    }
}

}






























<configuration>
  <system.web>
    <machineKey
      validationKey="C68C3C3F7F3D2E3B...A7B5D1C4E3F2A1B0"
      decryptionKey="A9F3C4E7D1B2F9A4C6E3F7B1A2D4C5E3"
      validation="HMACSHA256"
      decryption="AES" />
  </system.web>
</configuration>


else {
    String fieldName = field.getName();
    Integer columnIndex = columnMap.get(fieldName);
    ColumnData columnData = field.getAnnotation(ColumnData.class);

    if (columnIndex != null) {
        Object value = getFormattedCellValue(row.getCell(columnIndex), field.getType(), columnData);

        // Si es una relaci√≥n @ManyToOne, ir a buscar la entidad relacionada
        if (field.isAnnotationPresent(ManyToOne.class)) {
            if (value != null) {
                Class<?> relatedEntityClass = field.getType();
                Optional<Object> repo = resolver.getRepository(relatedEntityClass);

                if (repo.isPresent()) {
                    Object entityReference = repo.get().findById(value);
                    if (entityReference != null) {
                        field.set(entity, entityReference);
                    } else {
                        logger.warn("No se encontr√≥ entidad relacionada de tipo {} con ID {}", relatedEntityClass.getSimpleName(), value);
                    }
                } else {
                    logger.warn("No se encontr√≥ repositorio para {}", relatedEntityClass.getSimpleName());
                }
            }
        } else {
            field.set(entity, value);
        }
    }
}



<ui:repeat value="#{genericCrudBean.inputs}" var="input" varStatus="status">
    <p:selectOneMenu id="combo_#{status.index}"
                     value="#{genericCrudBean.formData[input.name]}"
                     rendered="#{input.relation and not input.radioSelection}"
                     converter="baseEntityConverter"
                     required="#{input.required}">
        
        <f:attribute name="fieldName" value="#{input.dropdownName}" />
        <f:attribute name="options" value="#{input.options}" />

        <f:selectItem itemLabel="#{input.label}" itemValue="#{null}" />
        <f:selectItems value="#{input.options}" var="opt"
                       itemLabel="#{opt.value}" itemValue="#{opt}" />

        <p:ajax event="change"
                listener="#{genericCrudBean.onDropdownChange}"
                update="@form" />
    </p:selectOneMenu>
</ui:repeat>







public static Func<RedirectToIdentityProviderNotification<OpenIdConnectMessage, OpenIdConnectAuthenticationOptions>, Task> 
    BuildRedirectToIdentityProvider(AuthProperties authProps)
{
    return context =>
    {
        var redirectUri = context.OwinContext?
            .Authentication?
            .AuthenticationResponseChallenge?
            .Properties?
            .RedirectUri;

        if (!string.IsNullOrEmpty(redirectUri))
        {
            context.ProtocolMessage.RedirectUri = redirectUri;
            authProps.RedirectUri = redirectUri;
        }

        return Task.CompletedTask;
    };
}






protected void Application_BeginRequest(object sender, EventArgs e)
{
    var context = HttpContext.Current;

    if (context.Request.Cookies["OriginalHost"] == null)
    {
        var redirectUri = /* tu l√≥gica para armar el redirect_uri din√°mico */;
        
        var cookie = new HttpCookie("OriginalHost", redirectUri)
        {
            HttpOnly = true,
            Secure = true
        };

        context.Response.Cookies.Add(cookie);

        // Forzar un redirect SOLO si no existe la cookie a√∫n
        context.Response.Redirect(context.Request.RawUrl, endResponse: true);
    }
}



HttpContext.Current.GetOwinContext().Set("CustomRedirectUri", redirectUri);

var customRedirect = context.OwinContext.Get<string>("CustomRedirectUri");

if (!string.IsNullOrEmpty(customRedirect))
{
    context.ProtocolMessage.RedirectUri = customRedirect;
}



var props = new AuthenticationProperties();
props.Dictionary["CustomRedirectUri"] = "https://scotiaworld.bns/hradmin/signin-oidc";

HttpContext.GetOwinContext().Authentication.Challenge(
    props,
    OpenIdConnectAuthenticationDefaults.AuthenticationType
);


if (context.Properties.Dictionary.TryGetValue("CustomRedirectUri", out var customRedirect))
{
    context.ProtocolMessage.RedirectUri = customRedirect;
}




var context = HttpContext.Current;

string currentUrl = context.Request.Url.ToString();
string redirectUri;

if (currentUrl.Contains("/hrapp/"))
{
    redirectUri = "https://tudominio/hrapp/esop/default.aspx";
}
else if (currentUrl.Contains("/scotiaworld/"))
{
    redirectUri = "https://tudominio/scotiaworld/esop/default.aspx";
}
else
{
    // Un fallback
    redirectUri = "https://tudominio/hrapp/esop/default.aspx";
}

var properties = new AuthenticationProperties
{
    RedirectUri = redirectUri
};

HttpContext.Current.GetOwinContext().Authentication.Challenge(properties, "YourOidcAuthenticationType");







app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    // Config b√°sica...
    ClientId = "...",
    Authority = "...",
    RedirectUri = "https://tudominio/scotiaw", // valor por defecto

    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        RedirectToIdentityProvider = context =>
        {
            var request = context.Request;

            // Extraer la ruta del request actual
            var path = request.Uri.AbsolutePath.ToLower();

            if (path.Contains("/hrapp"))
            {
                context.ProtocolMessage.RedirectUri = "https://tudominio/hrapp";
            }
            else if (path.Contains("/scotiaw"))
            {
                context.ProtocolMessage.RedirectUri = "https://tudominio/scotiaw";
            }

            return Task.CompletedTask;
        }
    }
});




<system.webServer>
  <rewrite>
    <rules>
      <rule name="Set HTTPS">
        <match url=".*" />
        <conditions>
          <add input="{HTTPS}" pattern="off" />
        </conditions>
        <serverVariables>
          <set name="HTTPS" value="on" />
        </serverVariables>
        <action type="None" />
      </rule>
    </rules>
  </rewrite>
</system.webServer>



app.Use(async (context, next) =>
{
    var request = context.Request;

    // Solo intercepta el POST desde WAM con tokens
    if (request.Path == new PathString("/hrpassiis/HRAdminPortal") &&
        request.Method == "POST")
    {
        var form = await request.ReadFormAsync();

        if (form.ContainsKey("id_token") || form.ContainsKey("code"))
        {
            // Redirige internamente a la ruta que OWIN s√≠ procesar√°
            context.Response.Redirect("/auth/callback");
            return;
        }
    }

    await next.Invoke();
});


CallbackPath = new PathString("/auth/callback")




<system.webServer>
  <httpProtocol>
    <customHeaders>
      <add name="Connection" value="keep-alive" />
    </customHeaders>
  </httpProtocol>
</system.webServer>



using System.Threading.Tasks;
using Microsoft.Owin;

public class RawOwinLoggerMiddleware : OwinMiddleware
{
    public RawOwinLoggerMiddleware(OwinMiddleware next) : base(next) { }

    public override async Task Invoke(IOwinContext context)
    {
        // Log de entrada
        LogHelper.Log($"[OWIN Raw] Incoming request: {context.Request.Method} {context.Request.Uri}",
                      LogHelper.LogLevel.Debug);

        foreach (var header in context.Request.Headers)
        {
            LogHelper.Log($"[OWIN Raw] Header: {header.Key} = {string.Join(",", header.Value)}",
                          LogHelper.LogLevel.Debug);
        }

        await Next.Invoke(context);

        // Log de salida
        LogHelper.Log($"[OWIN Raw] Outgoing response: {context.Response.StatusCode}",
                      LogHelper.LogLevel.Debug);

        foreach (var header in context.Response.Headers)
        {
            LogHelper.Log($"[OWIN Raw] Response Header: {header.Key} = {string.Join(",", header.Value)}",
                          LogHelper.LogLevel.Debug);
        }
    }
}


public void Configuration(IAppBuilder app)
{
    app.Use<RawOwinLoggerMiddleware>();

    // Luego tu auth
    ConfigureAuth(app);
}


<configuration>
  <system.diagnostics>
    <switches>
      <!-- Habilita todos los logs para Microsoft.Owin -->
      <add name="Microsoft.Owin" value="Verbose" />
    </switches>
  </system.diagnostics>
</configuration>

<configuration>
  ...

  <system.diagnostics>
    <switches>
      <add name="Microsoft.Owin" value="Verbose" />
      <add name="Microsoft.Owin.Security" value="Verbose" />
      <add name="Microsoft.Owin.Security.OpenIdConnect" value="Verbose" />
    </switches>
  </system.diagnostics>

  ...
</configuration>


var logger = app.CreateLogger("OWIN-Test");
logger.WriteInformation("Log de prueba desde OWIN");


using Microsoft.Owin.Logging;

public class SerilogLoggerFactory : ILoggerFactory
{
    public ILogger Create(string name)
    {
        return new SerilogLogger(name);
    }
}


using Microsoft.Owin.Logging;
using Serilog;
using System;
using System.Diagnostics;

public class SerilogLogger : ILogger
{
    private readonly string _name;

    public SerilogLogger(string name)
    {
        _name = name;
    }

    public bool WriteCore(TraceEventType eventType, int eventId, object state,
        Exception exception, Func<object, Exception, string> formatter)
    {
        if (formatter == null)
            return false;

        string message = formatter(state, exception);

        if (string.IsNullOrWhiteSpace(message))
            return false;

        // Tambi√©n lo pasamos por tu LogHelper para confirmar visualmente
        LogHelper.Log($"OWIN: [{eventType}] {_name} - {message}",
                      level: LogHelper.LogLevel.Debug);

        // Redirigimos a Serilog
        var logger = Log.ForContext("SourceContext", _name);

        switch (eventType)
        {
            case TraceEventType.Critical:
                logger.Fatal(exception, message);
                break;
            case TraceEventType.Error:
                logger.Error(exception, message);
                break;
            case TraceEventType.Warning:
                logger.Warning(exception, message);
                break;
            case TraceEventType.Information:
                logger.Information(exception, message);
                break;
            case TraceEventType.Verbose:
                logger.Verbose(exception, message);
                break;
            default:
                logger.Debug(exception, message);
                break;
        }

        return true;
    }
}


using Microsoft.Owin.Logging;
using System;
using System.Diagnostics;
using Serilog;

public class SerilogLogger : ILogger
{
    private readonly string _name;

    public SerilogLogger(string name)
    {
        _name = name;
    }

    public bool WriteCore(TraceEventType eventType, int eventId, object state,
        Exception exception, Func<object, Exception, string> formatter)
    {
        if (formatter == null) return false;

        var message = formatter(state, exception);
        if (string.IsNullOrWhiteSpace(message)) return false;

        var logger = Log.ForContext("SourceContext", _name);

        switch (eventType)
        {
            case TraceEventType.Critical:
                logger.Fatal(exception, message);
                break;
            case TraceEventType.Error:
                logger.Error(exception, message);
                break;
            case TraceEventType.Warning:
                logger.Warning(exception, message);
                break;
            case TraceEventType.Information:
                logger.Information(exception, message);
                break;
            case TraceEventType.Verbose:
                logger.Verbose(exception, message);
                break;
            default:
                logger.Debug(exception, message);
                break;
        }

        return true;
    }
}

public class SerilogLoggerFactory : ILoggerFactory
{
    public ILogger Create(string name)
    {
        return new SerilogLogger(name);
    }
}


 app.SetLoggerFactory(new SerilogLoggerFactory());








<?xml version="1.0" encoding="utf-8" ?>
<Weavers>
  <Costura />
</Weavers>
FodyWeavers.xml

<?xml version="1.0"?>
<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
  <metadata>
    <id>MyAuthLibrary</id> <!-- Nombre de tu librer√≠a -->
    <version>1.0.0</version> <!-- Versi√≥n del paquete -->
    <authors>Tu Nombre o Tu Empresa</authors>
    <owners>Tu Nombre o Tu Empresa</owners>
    <description>Una librer√≠a de autenticaci√≥n personalizada usando Owin y OpenID Connect</description>
    <copyright>Copyright 2025</copyright>
    <dependencies>
      <!-- Puedes agregar dependencias si las tiene -->
    </dependencies>
  </metadata>
  <files>
    <!-- Archivos que quieres incluir en el paquete -->
    <file src="bin\Release\MyAuthLibrary.dll" target="lib\net45" /> <!-- Cambia las rutas seg√∫n tu proyecto -->
  </files>
</package>


SecurityTokenValidated = async context =>
{
    var authManager = context.OwinContext.Authentication;

    // Extraer el ID token y verificar si realmente est√° llegando
    string idToken = context.ProtocolMessage.IdToken;
    if (string.IsNullOrEmpty(idToken))
    {
        context.HandleResponse();
        context.Response.Redirect("/Error?message=No ID Token");
        return;
    }

    // Crear lista de Claims
    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.NameIdentifier, context.AuthenticationTicket.Identity.FindFirst(ClaimTypes.NameIdentifier)?.Value ?? "Unknown"),
        new Claim("idtoken", idToken)
    };

    // Crear una nueva identidad con las claims y el esquema de autenticaci√≥n correcto
    var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationType);

    // Iniciar sesi√≥n con cookies
    authManager.SignIn(new AuthenticationProperties
    {
        IsPersistent = true,
        ExpiresUtc = DateTime.UtcNow.AddMinutes(10) // Puedes ajustar el tiempo de expiraci√≥n
    }, identity);
}



var authManager = context.OwinContext.Authentication;

            // Verificar si la cookie sigue existiendo
            if (!context.OwinContext.Request.Cookies.ContainsKey(".AspNet.Cookies"))
            {
                // Si la cookie no existe, forzar autenticaci√≥n con WAM
                context.HandleResponse();
                context.Response.Redirect(context.Options.Authority); // Redirige a WAM
            }

Notifications = new OpenIdConnectAuthenticationNotifications
{
    SecurityTokenValidated = async context =>
    {
        var identity = new ClaimsIdentity(context.AuthenticationTicket.Identity.Claims,
            CookieAuthenticationDefaults.AuthenticationType);

        var authManager = context.OwinContext.Authentication;

        if (context.OwinContext.Authentication.User.Identity.IsAuthenticated)
        {
            // Si el usuario est√° autenticado, renovar la cookie
            authManager.SignIn(new AuthenticationProperties
            {
                IsPersistent = true,
                ExpiresUtc = DateTime.UtcNow.AddMinutes(30) // Renueva cookie
            }, identity);
        }
        else
        {
            // Si no hay autenticaci√≥n, forzar logout
            authManager.SignOut(CookieAuthenticationDefaults.AuthenticationType);
            context.HandleResponse();
            context.Response.Redirect("/Account/Login"); // Redirigir al login
        }
    }
}


options.Events.OnRedirectToIdentityProvider = context =>
{
    var nonce = Guid.NewGuid().ToString(); 
    context.Properties.Items["nonce"] = nonce;
    context.ProtocolMessage.SetParameter("nonce", nonce);
    return Task.CompletedTask;
};


RedirectToIdentityProvider = context =>
{
    string nonce = Guid.NewGuid().ToString("N");

    context.OwinContext.Response.Cookies.Append(
        "OpenIdConnect.nonce." + nonce,
        nonce,
        new CookieOptions
        {
            HttpOnly = true,
            Secure = true,
            SameSite = SameSiteMode.None
        });

    context.ProtocolMessage.Nonce = nonce;
    return Task.CompletedTask;
};


CookieSameSite = Microsoft.Owin.SameSiteMode.None,
CookieSecure = CookieSecureOption.Always,
CookieSameSite = Microsoft.Owin.SameSiteMode.Lax, // O usar "Strict"


MessageReceived = context =>
{
    var cookies = context.OwinContext.Request.Cookies;
    foreach (var cookie in cookies)
    {
        Console.WriteLine($"[MessageReceived] Cookie: {cookie.Key} = {cookie.Value}");
    }
    return Task.CompletedTask;
},


if (context.Exception.Message.Contains("IDX21323"))
    {
        context.Response.Redirect("/error?message=nonce_error");
    }
    else
    {
        context.Response.Redirect("/error?message=" + Uri.EscapeDataString(context.Exception.Message));
    }

            context.Response.Redirect("/error?message=" + Uri.EscapeDataString(context.Exception.Message));



if (!tokenResponse.IsSuccessStatusCode)
        {
            // Loguear el error si falla la solicitud del token
            var errorContent = await tokenResponse.Content.ReadAsStringAsync();
            LogHelper.Log($"[Auth] Error al obtener el token: {errorContent}", level: LogHelper.LogLevel.Error);
            return;
        }


app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = ConfigurationManager.AppSettings["ClientId"],
    Authority = ConfigurationManager.AppSettings["Authority"],
    RedirectUri = ConfigurationManager.AppSettings["RedirectUri"],
    ResponseType = OpenIdConnectResponseType.IdToken,
    UseTokenLifetime = false,
    
    TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true
    },

    ProtocolValidator = new OpenIdConnectProtocolValidator
    {
        RequireNonce = true // ‚úÖ Aqu√≠ s√≠ es v√°lido
    }
});


app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
    SlidingExpiration = true, // üîÑ Renueva el tiempo de expiraci√≥n con cada solicitud
    ExpireTimeSpan = TimeSpan.FromMinutes(60), // ‚è≥ Expira en 60 minutos
    CookieSecure = CookieSecureOption.Always, // üîê Solo permite cookies en HTTPS
    CookieHttpOnly = true, // üõë Previene acceso a la cookie desde JavaScript
    CookieSameSite = SameSiteMode.None, // ‚ö†Ô∏è Permite compartir cookies entre sitios (si necesario)
    CookiePath = "/", // üìç Asegura que se almacene correctamente la cookie
    LoginPath = new PathString("/Auth/Login.aspx"), // üîÑ Ruta de login si la sesi√≥n expira
    LogoutPath = new PathString("/Auth/Logout.aspx") // üö™ Ruta de logout
});

AuthenticationFailed = context =>
{
    LogHelper.Log($"[Auth] Authentication Failed: {context.Exception.Message}", level: LogHelper.LogLevel.Error);
    LogHelper.Log($"[Auth] Full Exception: {context.Exception}", level: LogHelper.LogLevel.Debug);
    
    // Registrar m√°s detalles sobre el contexto
    if (context.ProtocolMessage != null)
    {
        LogHelper.Log($"[Auth] Protocol Message: {context.ProtocolMessage}", level: LogHelper.LogLevel.Debug);
    }

    return Task.CompletedTask;
},

app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    AuthenticationMode = AuthenticationMode.Passive,
    ClientId = ConfigurationManager.AppSettings["ClientId"],
    Authority = ConfigurationManager.AppSettings["Authority"],
    RedirectUri = ConfigurationManager.AppSettings["RedirectUri"],
    ResponseType = OpenIdConnectResponseType.IdToken,
    UseTokenLifetime = false, // ‚è≥ Evita que la autenticaci√≥n dependa solo del token
    TokenValidationParameters = new TokenValidationParameters
    {
        RequireNonce = true, // ‚úÖ Asegura que el nonce se usa correctamente
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true
    }
});


LogHelper.Log($"[Auth] Authentication Failed!", level: LogHelper.LogLevel.Error);
    LogHelper.Log($"Exception: {context.Exception}", level: LogHelper.LogLevel.Error);
    LogHelper.Log($"ProtocolMessage: {context.ProtocolMessage?.ToString()}", level: LogHelper.LogLevel.Error);
    LogHelper.Log($"Request.Path: {context.Request?.Path}", level: LogHelper.LogLevel.Error);
    LogHelper.Log($"RedirectUri: {context.Options?.RedirectUri}", level: LogHelper.LogLevel.Error);

AuthenticationFailed = context =>
{
    string contextData = JsonConvert.SerializeObject(context, Formatting.Indented);
    LogHelper.Log($"[Auth] Authentication Failed Context: {contextData}", level: LogHelper.LogLevel.Error);

    return Task.CompletedTask;
};



app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ...
    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        RedirectToIdentityProvider = context =>
        {
            // Forzar nuevo nonce
            context.ProtocolMessage.Nonce = Guid.NewGuid().ToString();
            return Task.CompletedTask;
        }
    }
});


string errorMessage = context.Failure != null ? context.Failure.Message : "No failure message";
    LoggingLogHelper.Log($"[Startup] AuthenticationFailed: {errorMessage}", environment: "", level: LoggingLogHelper.LogLevel.Debug);
 
string user = context.Principal?.Identity?.Name ?? "Usuario no autenticado";
    LoggingLogHelper.Log($"[Startup] AuthenticationFailed - Usuario: {user}", environment: "", level: LoggingLogHelper.LogLevel.Debug);

if (context.Principal != null)
    {
        foreach (var claim in context.Principal.Claims)
        {
            LoggingLogHelper.Log($"[Startup] Claim: {claim.Type} - {claim.Value}", environment: "", level: LoggingLogHelper.LogLevel.Debug);
        }
    }
    else
    {
        LoggingLogHelper.Log("[Startup] No se recibieron claims", environment: "", level: LoggingLogHelper.LogLevel.Debug);
    }

var headers = context.Request.Headers;
    foreach (var header in headers)
    {
        LoggingLogHelper.Log($"[Startup] Header: {header.Key} - {header.Value}", environment: "", level: LoggingLogHelper.LogLevel.Debug);
    }

app.UseCookieAuthentication(new CookieAuthenticationOptions
{
    AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
    ExpireTimeSpan = TimeSpan.FromMinutes(30),

    Events = new CookieAuthenticationEvents
    {
        OnRedirectToLogin = context =>
        {
            // URL de WAM obtenida de configuraci√≥n
            string wamRedirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];
            
            // Redirigir al usuario a WAM si no est√° autenticado
            context.Response.Redirect(wamRedirectUri);
            return Task.CompletedTask;
        }
    }
});


<system.webServer>
    <modules runAllManagedModulesForAllRequests="true">
        <add name="Owin" type="Microsoft.Owin.Host.SystemWeb.OwinHttpModule, Microsoft.Owin.Host.SystemWeb" />
    </modules>
</system.webServer>


using Microsoft.Owin.Security;
using System.Security.Claims;

var user = HttpContext.Current.GetOwinContext().Authentication.User;
if (user.Identity.IsAuthenticated)
{
    string userName = user.Identity.Name; // Nombre del usuario autenticado
    string email = user.FindFirst(ClaimTypes.Email)?.Value; // Correo electr√≥nico
    string userId = user.FindFirst(ClaimTypes.NameIdentifier)?.Value; // ID del usuario
    string role = user.FindFirst(ClaimTypes.Role)?.Value; // Rol del usuario (si est√° disponible)
}


<add key="serilog:using:Debug" value="Serilog.Sinks.Debug"/>
<add key="serilog:write-to:Debug"/>

HttpContext.Current.GetOwinContext().Authentication.SignOut(
        CookieAuthenticationDefaults.AuthenticationType, 
        OpenIdConnectAuthenticationDefaults.AuthenticationType
    );

    Response.Redirect("~/Auth/Login.aspx");


public void Configuration(IAppBuilder app)
{
    // Configurar autenticaci√≥n con cookies
    app.UseCookieAuthentication(new CookieAuthenticationOptions
    {
        AuthenticationType = CookieAuthenticationDefaults.AuthenticationType
    });

    // Configurar autenticaci√≥n con OpenID Connect
    app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
    {
        ClientId = "tu-client-id",
        Authority = "https://wam-ist.cloud.bns:443/sso/oauth2/bns",
        RedirectUri = "https://tu-app/callback",
        ResponseType = OpenIdConnectResponseType.CodeIdToken,
        SignInAsAuthenticationType = CookieAuthenticationDefaults.AuthenticationType
    });
}


app.UseCookieAuthentication(new CookieAuthenticationOptions());



https://wam-ist.cloud.bns/sso/oauth2/bns/.well-known/openid-configuration

2Ô∏è‚É£ Si WAM no tiene metadatos, configura manualmente los endpoints:

app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = "tu-cliente-id",
    Authority = "https://wam-ist.cloud.bns/sso/oauth2/bns",
    RedirectUri = "https://tu-aplicacion.com/signin-oidc",
    ResponseType = OpenIdConnectResponseType.CodeIdToken,
    Scope = "openid profile",
    TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = false
    },
    Configuration = new OpenIdConnectConfiguration
    {
        AuthorizationEndpoint = "https://wam-ist.cloud.bns/sso/oauth2/bns/authorize",
        TokenEndpoint = "https://wam-ist.cloud.bns/sso/oauth2/bns/token",
        UserInfoEndpoint = "https://wam-ist.cloud.bns/sso/oauth2/bns/userinfo"
    }
});




app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = "tu-cliente-id",
    Authority = "https://wam-ist.cloud.bns/sso/oauth2/bns",
    MetadataAddress = "https://wam-ist.cloud.bns/sso/oauth2/bns/authorize", // Usa la URL correcta
    RedirectUri = "https://tu-aplicacion.com/signin-oidc", // Cambia esto por la URL de tu app
    ResponseType = OpenIdConnectResponseType.CodeIdToken,
    Scope = "openid profile",
    TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = false
    }
});



public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        string clientid = ConfigurationManager.AppSettings["WamClientId"];
        string secret = ConfigurationManager.AppSettings["WamClientSecret"];
        string authority = ConfigurationManager.AppSettings["WamAuthority"];
        string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];
        string responseType = ConfigurationManager.AppSettings["WamResponseType"];
        string postlogoutRedirectUri = ConfigurationManager.AppSettings["PostLogoutRedirectUri"];

        int expireTimeSpan = int.TryParse(ConfigurationManager.AppSettings["ExpireTimeSpan"], out int minutes) ? minutes : 30;

        if (string.IsNullOrEmpty(clientid) || string.IsNullOrEmpty(secret) || string.IsNullOrEmpty(authority) || string.IsNullOrEmpty(redirectUri) || string.IsNullOrEmpty(responseType))
        {
            throw new Exception("Missing settings in Web.config");
        }

        ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
        IdentityModelEventSource.ShowPII = true;

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = "Cookies",
            ExpireTimeSpan = TimeSpan.FromMinutes(expireTimeSpan),
            SlidingExpiration = true,
            LoginPath = new PathString("/Auth/Login.aspx"), // ‚úÖ CORREGIDO
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = clientid,
            ClientSecret = secret,
            Authority = authority,
            RedirectUri = redirectUri,
            ResponseType = responseType, // Asegurar que sea "code id_token"
            Scope = "openid",
            SignInAsAuthenticationType = "Cookies",
            SaveTokens = true,
            PostLogoutRedirectUri = postlogoutRedirectUri,

            Notifications = new OpenIdConnectAuthenticationNotifications
            {
                SecurityTokenValidated = context =>
                {
                    var identity = (ClaimsIdentity)context.AuthenticationTicket.Identity;
                    var idToken = context.ProtocolMessage.IdToken;

                    if (!string.IsNullOrEmpty(idToken))
                    {
                        identity.AddClaim(new Claim("id.token", idToken));
                    }

                    return Task.CompletedTask;
                },
                AuthorizationCodeReceived = async context =>
                {
                    var code = context.Code;
                    var tokenClient = new HttpClient();
                    var tokenResponse = await tokenClient.PostAsync(ConfigurationManager.AppSettings["TokenEndpoint"],
                        new FormUrlEncodedContent(new Dictionary<string, string>
                        {
                            {"client_id", clientid },
                            {"client_secret", secret },
                            { "code", code },
                            { "redirect_uri", redirectUri },
                            { "grant_type", "authorization_code" }, // ‚úÖ CORREGIDO
                        }));
                    var tokenResult = await tokenResponse.Content.ReadAsStringAsync();

                    // ‚úÖ IMPORTANTE: Guardar la sesi√≥n
                    var authenticationManager = context.OwinContext.Authentication;
                    authenticationManager.SignIn(new AuthenticationProperties(), context.AuthenticationTicket.Identity);
                },
                AuthenticationFailed = context =>
                {
                    context.HandleResponse();
                    context.Response.Redirect("/Auth/Logout.aspx");
                    return Task.CompletedTask;
                }
            },
        });
    }
}



public void ConfigureAuth(IAppBuilder app)
{
    app.UseCookieAuthentication(new CookieAuthenticationOptions
    {
        AuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
        LoginPath = new PathString("/Auth/Logout.aspx"), // Esto NO es el login, sino la p√°gina de error
        ExpireTimeSpan = TimeSpan.FromMinutes(30),
        SlidingExpiration = true
    });

    app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
    {
        Authority = "https://tu-wam-provider.com/",
        ClientId = "tu-client-id",
        RedirectUri = "https://tu-app.com/signin-oidc",
        ResponseType = OpenIdConnectResponseType.CodeIdToken,
        Scope = "openid profile",
        SignInAsAuthenticationType = CookieAuthenticationDefaults.AuthenticationType,
        SaveTokens = true,
        Notifications = new OpenIdConnectAuthenticationNotifications
        {
            AuthenticationFailed = context =>
            {
                context.HandleResponse();
                context.Response.Redirect("/Auth/Logout.aspx"); // Redirige a la p√°gina de error si falla la autenticaci√≥n
                return Task.CompletedTask;
            }
        }
    });
}

protected void Page_Load(object sender, EventArgs e)
{
    if (!User.Identity.IsAuthenticated)
    {
        HttpContext.Current.GetOwinContext().Authentication.Challenge(
            new AuthenticationProperties { RedirectUri = "/" },
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );
    }
    else
    {
        Response.Redirect("~/Default.aspx");
    }
}


protected void Page_Load(object sender, EventArgs e)
{
    if (Request.IsAuthenticated)
    {
        HttpContext.Current.GetOwinContext().Authentication.SignOut(
            CookieAuthenticationDefaults.AuthenticationType,
            OpenIdConnectAuthenticationDefaults.AuthenticationType
        );
    }

    Response.Redirect("~/Auth/ForceLogin.aspx"); // Vuelve a redirigir al login
}




HttpContext.Current.GetOwinContext().Authentication.Challenge(
                new AuthenticationProperties { RedirectUri = Request.Url.ToString() },
                OpenIdConnectAuthenticationDefaults.AuthenticationType
            );



<%@ Page Language="C#" AutoEventWireup="true" CodeBehind="Logout.aspx.cs" Inherits="TuProyecto.Logout" %>

<!DOCTYPE html>
<html lang="es">
<head runat="server">
    <meta charset="utf-8" />
    <title>No Autenticado</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin-top: 50px; }
        .container { max-width: 400px; margin: auto; padding: 20px; border: 1px solid #ccc; border-radius: 10px; }
        h2 { color: red; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
        button:hover { background-color: #0056b3; }
    </style>
</head>
<body>
    <div class="container">
        <h2>¬°Acceso no permitido!</h2>
        <p>No tienes una sesi√≥n activa. Por favor, inicia sesi√≥n para continuar.</p>
        <button onclick="window.location.href='Default.aspx'">Volver a la P√°gina Principal</button>
    </div>
</body>
</html>

using System;
using System.Web;
using System.Web.UI;

namespace TuProyecto
{
    public partial class Logout : Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            // Cerrar sesi√≥n
            Session.Clear();  // Elimina todas las variables de sesi√≥n
            Session.Abandon(); // Finaliza la sesi√≥n actual
            HttpContext.Current.User = null; // Borra la identidad del usuario
            
            // Redirigir al Login despu√©s de 5 segundos
            Response.AppendHeader("Refresh", "5;url=Login.aspx");
        }
    }
}



public class AuthPage : System.Web.UI.Page
{
    protected override void OnInit(EventArgs e)
    {
        base.OnInit(e); // Llamar a la implementaci√≥n base de OnInit

        if (!HttpContext.Current.User.Identity.IsAuthenticated)
        {
            // Mostrar un mensaje en la consola del navegador
            ClientScript.RegisterStartupScript(this.GetType(), "consoleLog", "console.log('[AuthPage] No autenticado! Redirigiendo...');", true);

            // Redirigir al login
            Response.Redirect("~/Login.aspx", true);
            
            // IMPORTANTE: Detener la ejecuci√≥n de la p√°gina
            Context.ApplicationInstance.CompleteRequest();
        }
    }

    protected override void OnLoad(EventArgs e)
    {
        base.OnLoad(e); // Llamar a la implementaci√≥n base de OnLoad

        // Si el usuario ya est√° autenticado, obtener el token
        var identity = (ClaimsIdentity)HttpContext.Current.User.Identity;
        var idTokenClaim = identity.FindFirst("id.token");

        if (idTokenClaim != null)
        {
            string idToken = idTokenClaim.Value;

            // Mostrar el ID Token en la consola del navegador
            ClientScript.RegisterStartupScript(this.GetType(), "consoleLogId", $"console.log('ID Token: {idToken}');", true);
        }
    }
}



if (this is System.Web.UI.Page)
{
    Response.Write("ESOP_Landing efectivamente hereda de Page");
}



EnableViewState="true"

 AutoEventWireup="true"


SecurityTokenValidated = context =>
{
    var identity = (ClaimsIdentity)context.AuthenticationTicket.Identity;

    // Obtener el id_token desde el contexto
    var idToken = context.ProtocolMessage.IdToken;

    if (!string.IsNullOrEmpty(idToken))
    {
        // Agregar el id_token como un claim
        identity.AddClaim(new Claim("id_token", idToken));
    }

    return Task.CompletedTask;
}



ClientScript.RegisterStartupScript(this.GetType(), "consoleLog",
                $"console.log('ID Token: {idToken}');", true);


ClientScript.RegisterStartupScript(this.GetType(), "consoleLog", "console.log('Mensaje desde el servidor');", true);


var identity = (ClaimsIdentity)HttpContext.Current.User.Identity;
var idTokenClaim = identity.FindFirst("id_token");

if (idTokenClaim != null)
{
    string idToken = idTokenClaim.Value;
    Console.WriteLine("ID Token: " + idToken);
}




app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
{
    ClientId = ConfigurationManager.AppSettings["ClientId"],
    Authority = ConfigurationManager.AppSettings["Authority"],
    RedirectUri = ConfigurationManager.AppSettings["RedirectUri"],
    ResponseType = "code",  // Se usa "code" en lugar de "id_token"
    Scope = "openid profile",
    SignInAsAuthenticationType = "Cookies",
    UseTokenLifetime = false,
    Notifications = new OpenIdConnectAuthenticationNotifications
    {
        AuthorizationCodeReceived = async context =>
        {
            var code = context.Code;

            // Intercambiar el c√≥digo por tokens (Acceso y Refresh Token)
            var tokenClient = new HttpClient();
            var tokenResponse = await tokenClient.PostAsync(ConfigurationManager.AppSettings["TokenEndpoint"], 
                new FormUrlEncodedContent(new Dictionary<string, string>
                {
                    { "client_id", ConfigurationManager.AppSettings["ClientId"] },
                    { "client_secret", ConfigurationManager.AppSettings["ClientSecret"] },
                    { "code", code },
                    { "redirect_uri", ConfigurationManager.AppSettings["RedirectUri"] },
                    { "grant_type", "authorization_code" }
                }));

            var tokenResult = await tokenResponse.Content.ReadAsStringAsync();
            // Procesar tokens aqu√≠ (acceso, refresh, etc.)
        }
    }
});



using System;
using System.Web;

namespace OIDC.WebForm
{
    public class BasePage : System.Web.UI.Page
    {
        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            if (!Request.IsAuthenticated) // Verifica si el usuario est√° autenticado
            {
                Response.Redirect("~/Login.aspx"); // Redirige al login si no est√° autenticado
            }
        }
    }
}




int expirationMinutes = int.TryParse(ConfigurationManager.AppSettings["AuthCookieExpirationMinutes"], out int minutes) ? minutes : 30;

using System;
using System.Configuration;
using Microsoft.Owin;
using Microsoft.Owin.Security.Cookies;
using Microsoft.Owin.Security.OpenIdConnect;
using Owin;

public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        string clientId = ConfigurationManager.AppSettings["WamClientId"];
        string tenantId = ConfigurationManager.AppSettings["WamTenantId"];
        string authority = ConfigurationManager.AppSettings["WamAuthority"];
        string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

        if (string.IsNullOrEmpty(clientId) || string.IsNullOrEmpty(tenantId) || 
            string.IsNullOrEmpty(authority) || string.IsNullOrEmpty(redirectUri))
        {
            throw new Exception("Faltan configuraciones en web.config");
        }

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = "Cookies"
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = clientId,
            Authority = authority,
            RedirectUri = redirectUri,
            ResponseType = "code id_token",
            Scope = "openid profile email",
            SignInAsAuthenticationType = "Cookies",
            UseTokenLifetime = false,
            SaveTokens = true
        });
    }
}
        int expirationMinutes = int.TryParse(ConfigurationManager.AppSettings["AuthCookieExpirationMinutes"], out int minutes) ? minutes : 30;


<configuration>
  <appSettings>
    <add key="WamClientId" value="tu-client-id" />
    <add key="WamTenantId" value="tu-tenant-id" />
    <add key="WamAuthority" value="https://login.microsoftonline.com/{tu-tenant-id}/v2.0" />
    <add key="WamRedirectUri" value="https://localhost:44333/signin-oidc" />
  </appSettings>
</configuration>


using System;
using System.Configuration;
using Microsoft.Owin;
using Microsoft.Owin.Security.Cookies;
using Microsoft.Owin.Security.OpenIdConnect;
using Owin;

public class Startup
{
    public void Configuration(IAppBuilder app)
    {
        string clientId = ConfigurationManager.AppSettings["WamClientId"];
        string tenantId = ConfigurationManager.AppSettings["WamTenantId"];
        string authority = ConfigurationManager.AppSettings["WamAuthority"];
        string redirectUri = ConfigurationManager.AppSettings["WamRedirectUri"];

        if (string.IsNullOrEmpty(clientId) || string.IsNullOrEmpty(tenantId) || 
            string.IsNullOrEmpty(authority) || string.IsNullOrEmpty(redirectUri))
        {
            throw new Exception("Faltan configuraciones en web.config");
        }

        app.UseCookieAuthentication(new CookieAuthenticationOptions
        {
            AuthenticationType = "Cookies"
        });

        app.UseOpenIdConnectAuthentication(new OpenIdConnectAuthenticationOptions
        {
            ClientId = clientId,
            Authority = authority,
            RedirectUri = redirectUri,
            ResponseType = "code id_token",
            Scope = "openid profile email",
            SignInAsAuthenticationType = "Cookies",
            UseTokenLifetime = false,
            SaveTokens = true
        });
    }
}






<br /><br />

        <!-- Campo de entrada para recibir el c√≥digo -->
        <label for="txtCode">C√≥digo:</label>
        <asp:TextBox ID="txtCode" runat="server"></asp:TextBox>

        <br /><br />


<asp:Button ID="btnLogout" runat="server" Text="Logout" OnClick="LogoutButton_Click" CssClass="btn btn-danger" />



using System;
using System.Web;
using System.Web.UI;

namespace OIDC.NETFramework
{
    public partial class Callback : Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            // 1Ô∏è‚É£ Verificar si hubo error en la autenticaci√≥n
            string error = Request.QueryString["error"];
            if (!string.IsNullOrEmpty(error))
            {
                Response.Write("Error en autenticaci√≥n: " + error);
                return;
            }

            // 2Ô∏è‚É£ Obtener par√°metros de la respuesta OIDC
            string code = Request.QueryString["code"];
            string idToken = Request.QueryString["id_token"];
            string state = Request.QueryString["state"];

            // 3Ô∏è‚É£ Validar el 'state' para prevenir ataques CSRF
            string expectedState = Session["oidc_state"] as string;
            if (string.IsNullOrEmpty(state) || state != expectedState)
            {
                Response.Write("Error: El par√°metro 'state' no coincide. Posible ataque CSRF.");
                return;
            }

            // 4Ô∏è‚É£ Si recibimos 'code', podemos intercambiarlo por tokens (Authorization Code Flow)
            if (!string.IsNullOrEmpty(code))
            {
                Response.Write("C√≥digo de autorizaci√≥n recibido: " + code);
                // Aqu√≠ debes hacer una solicitud HTTP al token endpoint para obtener access_token y id_token
                // (Necesitas un m√©todo para hacer un POST a `token_uri`).
            }

            // 5Ô∏è‚É£ Si ya recibimos el 'id_token', significa que el usuario est√° autenticado
            if (!string.IsNullOrEmpty(idToken))
            {
                Response.Write("ID Token recibido, autenticaci√≥n exitosa.");
                // Aqu√≠ puedes decodificar el id_token y extraer la informaci√≥n del usuario.
            }
        }
    }
}


<EnableAutoLaunch>false</EnableAutoLaunch>
protected void Page_Load(object sender, EventArgs e)
{
    if (User.Identity.IsAuthenticated)
    {
        var claimsIdentity = (ClaimsIdentity)User.Identity;
        var idToken = claimsIdentity.FindFirst("id_token")?.Value;

        if (idToken != null)
        {
            Response.Write("ID Token: " + idToken);
        }
    }
}





using System;
using System.Collections.Specialized;
using System.Net;
using System.Text;
using System.Web;
using Newtonsoft.Json.Linq;

namespace OIDC.NETFramework
{
    public partial class Callback : System.Web.UI.Page
    {
        protected void Page_Load(object sender, EventArgs e)
        {
            string code = Request.QueryString["code"];
            if (string.IsNullOrEmpty(code))
            {
                Response.Write("Error: No se recibi√≥ el c√≥digo de autorizaci√≥n.");
                return;
            }

            string tokenUrl = "https://wam-ist.cloud.bns/sso/oauth2/bns/access_token";
            using (WebClient client = new WebClient())
            {
                var postData = new NameValueCollection();
                postData["grant_type"] = "authorization_code";
                postData["client_id"] = "HRSSORefresh";
                postData["client_secret"] = "36567bd2-666e-491c-a511-5028eb7a4f13";
                postData["code"] = code;
                postData["redirect_uri"] = "https://localhost:44333/oidc/callback";

                byte[] responseBytes = client.UploadValues(tokenUrl, "POST", postData);
                string responseString = Encoding.UTF8.GetString(responseBytes);
                JObject tokenResponse = JObject.Parse(responseString);

                string idToken = tokenResponse["id_token"]?.ToString();
                string accessToken = tokenResponse["access_token"]?.ToString();

                if (string.IsNullOrEmpty(idToken))
                {
                    Response.Write("Error: No se recibi√≥ un ID Token.");
                    return;
                }

                // Guardar en sesi√≥n para validar autenticaci√≥n
                Session["id_token"] = idToken;
                Session["access_token"] = accessToken;

                Response.Redirect("Default.aspx");
            }
        }
    }
}


curl -X POST "https://wam-ist.cloud.bns/sso/oauth2/bns/access_token" \
     -H "Content-Type: application/x-www-form-urlencoded" \
     -d "grant_type=authorization_code" \
     -d "client_id=HRSSORefresh" \
     -d "client_secret=36567bd2-666e-491c-a511-5028eb7a4f13" \
     -d "code=TU_AUTH_CODE" \
     -d "redirect_uri=https://localhost:44333/oidc/callback"




using (var client = new HttpClient())
{
    var tokenUrl = "https://wam-ist.cloud.bns/sso/oauth2/bns/access_token";

    var postData = new Dictionary<string, string>
    {
        { "grant_type", "authorization_code" },
        { "client_id", "HRSSORefresh" },
        { "client_secret", "36567bd2-666e-491c-a511-5028eb7a4f13" },
        { "code", code },
        { "redirect_uri", "https://localhost:44333/oidc/callback" }
    };

    var content = new FormUrlEncodedContent(postData);

    HttpResponseMessage response = await client.PostAsync(tokenUrl, content);
    string responseString = await response.Content.ReadAsStringAsync();

    Response.Write(responseString); // Para ver la respuesta del servidor
}



try
                {
                    HttpResponseMessage response = client.PostAsync(tokenUrl, content).Result;
                    string responseString = response.Content.ReadAsStringAsync().Result;

                    Response.Write(responseString); // Verifica si recibes el access_token
                }
                catch (Exception ex)
                {
                    Response.Write("Error en la solicitud del token: " + ex.Message);
                }




protected void SignInUser(string userName, string idToken)
{
    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.Name, userName),
        new Claim("id_token", idToken) // Guardar ID Token si es necesario
    };

    var identity = new ClaimsIdentity(claims, "Cookies");

    var ctx = HttpContext.Current.GetOwinContext();
    var authManager = ctx.Authentication;

    authManager.SignIn(new AuthenticationProperties { IsPersistent = true }, identity);
}



curl -X POST https://tu-idp.com/token \
  -d "grant_type=password" \
  -d "client_id=tu-client-id" \
  -d "client_secret=tu-client-secret" \
  -d "username=usuario@ejemplo.com" \
  -d "password=contrase√±a-del-usuario" \
  -d "scope=openid" \
  -d "redirect_uri=https://localhost:44333/oidc/callback"



public void SignOutUser()
{
    var ctx = HttpContext.Current.GetOwinContext();
    var authManager = ctx.Authentication;

    // Cerrar sesi√≥n y eliminar la cookie
    authManager.SignOut("Cookies");
}


<button id="logoutButton" runat="server" class="btn btn-danger" OnClick="LogoutButton_Click">Logout</button>

