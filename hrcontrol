public int getDecimalPlaces() {
    return scale;
}

public String getMaxValuePattern() {
    int integerDigits = precision - scale;
    StringBuilder pattern = new StringBuilder();
    for (int i = 0; i < integerDigits; i++) {
        pattern.append("9");
    }
    if (scale > 0) {
        pattern.append(".");
        for (int i = 0; i < scale; i++) {
            pattern.append("9");
        }
    }
    return pattern.toString(); // e.g. "9999.9999"
}



public boolean isIntegerType() {
    return (type == Integer.class || type == int.class || type == Long.class || type == long.class)
            && !readOnly;
}

public boolean isDecimalType() {
    return type == BigDecimal.class && !readOnly;
}


public boolean isDecimalType() {
    return (type == BigDecimal.class || type == Double.class || type == Float.class) && !readOnly;
}



private Object convertToFieldType(Field field, Object value) {
    if (!(value instanceof String strValue)) {
        return value;
    }

    Class<?> targetType = field.getType();

    try {
        strValue = strValue.replace(",", "").trim(); // elimina separador de miles

        if (targetType == BigDecimal.class) {
            return new BigDecimal(strValue);
        } else if (targetType == Double.class || targetType == double.class) {
            return Double.parseDouble(strValue);
        } else if (targetType == Float.class || targetType == float.class) {
            return Float.parseFloat(strValue);
        } else if (targetType == Long.class || targetType == long.class) {
            return Long.parseLong(strValue);
        } else if (targetType == Integer.class || targetType == int.class) {
            return Integer.parseInt(strValue);
        } else if (targetType == Short.class || targetType == short.class) {
            return Short.parseShort(strValue);
        }
    } catch (NumberFormatException e) {
        logger.warn("Could not convert value [{}] to type [{}] for field [{}]",
                strValue, targetType.getSimpleName(), field.getName());
    }

    return value; // fallback si no pudo convertir
}
