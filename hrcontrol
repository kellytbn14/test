<p:inputText id="campo"
             value="#{bean.valor}"
             required="true"
             maxlength="20">
    <f:passThroughAttribute name="minlength" value="12"/>
    <f:validateLength minimum="12" maximum="20"/>
</p:inputText>






import jakarta.persistence.Id;

public String getIdFieldName(Class<?> clazz) {
    for (Field field : clazz.getDeclaredFields()) {
        if (field.isAnnotationPresent(Id.class)) {
            return field.getName();
        }
    }

    // También puedes buscar en superclases si el ID está ahí
    Class<?> superClass = clazz.getSuperclass();
    if (superClass != null && superClass != Object.class) {
        return getIdFieldName(superClass);
    }

    return null;
}



String[] safeFilters = filters != null ? filters : new String[0];


public <T extends BaseEntity<E>, E> List<FormOption> findAllFormOptions(
        Class<?> entityClass, String displayValue, String[] filters) {

    BaseRepository<T, E> repository = getRepository(entityClass);

    Map<String, Object> filterMap = Arrays.stream(filters)
        .map(f -> f.split(":", 2))
        .filter(arr -> arr.length == 2)
        .collect(Collectors.toMap(arr -> arr[0], arr -> convert(arr[1])));

    return repository.findAll().stream()
        .filter(obj -> matchesFilters(obj, filterMap))
        .map(obj -> {
            Object value = resolveProperty(obj, displayValue);
            return new FormOption(((BaseEntity<?>) obj).getId(), String.valueOf(value), obj.getClass());
        })
        .toList();
}
✅ matchesFilters
java
Copiar
Editar
private boolean matchesFilters(Object obj, Map<String, Object> filters) {
    for (Map.Entry<String, Object> entry : filters.entrySet()) {
        Object fieldValue = resolveProperty(obj, entry.getKey());

        if (fieldValue == null || !fieldValue.equals(entry.getValue())) {
            return false;
        }
    }
    return true;
}
✅ convert (para convertir "true" → Boolean, "123" → Integer, etc.)
java
Copiar
Editar
private Object convert(String raw) {
    if ("true".equalsIgnoreCase(raw) || "false".equalsIgnoreCase(raw)) {
        return Boolean.parseBoolean(raw);
    }

    try {
        return Integer.parseInt(raw);
    } catch (NumberFormatException ignored) { }

    return raw;
}













public <T extends BaseEntity<E>, E> List<FormOption> findAllFormOptions(Class<?> entityClass, String displayValue) {
    BaseRepository<T, E> repository = getRepository(entityClass);
    EntityReference ref = findEntityReferenceAnnotation(entityClass, displayValue);

    Map<String, Object> filterMap = new HashMap<>();

    if (ref != null) {
        for (String filter : ref.filters()) {
            String[] parts = filter.split(":", 2);
            if (parts.length == 2) {
                filterMap.put(parts[0], convert(parts[1]));
            }
        }
    }

    return repository.findAll().stream()
        .filter(obj -> matchesFilters(obj, filterMap))
        .map(obj -> {
            Object value = resolveProperty(obj, displayValue);
            return new FormOption(obj.getId(), String.valueOf(value), obj.getClass());
        })
        .toList();
}
✅ Método matchesFilters(...)
java
Copiar
Editar
private boolean matchesFilters(Object obj, Map<String, Object> filters) {
    for (Map.Entry<String, Object> entry : filters.entrySet()) {
        Object fieldValue = resolveProperty(obj, entry.getKey());
        if (fieldValue == null || !fieldValue.equals(entry.getValue())) {
            return false;
        }
    }
    return true;
}
✅ Método findEntityReferenceAnnotation(...) (igual que antes)
java
Copiar
Editar
private EntityReference findEntityReferenceAnnotation(Class<?> entityClass, String displayValue) {
    for (Field field : entityClass.getDeclaredFields()) {
        EntityReference ref = field.getAnnotation(EntityReference.class);
        if (ref != null && displayValue.equals(ref.fieldName())) {
            return ref;
        }
    }
    return null;
}
✅ Método convert(...) simple
java
Copiar
Editar
private Object convert(String raw) {
    if ("true".equalsIgnoreCase(raw)) return true;
    if ("false".equalsIgnoreCase(raw)) return false;
    if (raw.matches("-?\\d+")) return Integer.parseInt(raw);
    return raw;
}


















✅ Paso 1: Suposiciones
TmGenericControl es la entidad de donde se llena el dropdown.

filters = {"type:ROLE", "active:true"} indica que se debe filtrar por type = 'ROLE' y active = true.

Estás usando un método genérico como este:

java
Copiar
Editar
public <T extends BaseEntity<E>, E> List<FormOption> findAllFormOptions(Class<?> entityClass, String displayValue)
✅ Paso 2: Implementación organizada
java
Copiar
Editar
public <T extends BaseEntity<E>, E> List<FormOption> findAllFormOptions(Class<?> entityClass, String displayValue) {
    BaseRepository<T, E> repository = getRepository(entityClass);
    List<T> allItems = repository.findAll();

    return allItems.stream()
        .filter(item -> matchesEntityReferenceFilters(item, entityClass))
        .map(obj -> {
            Object value = resolveProperty(obj, displayValue);
            return new FormOption(obj.getId(), String.valueOf(value), obj.getClass());
        })
        .toList();
}
✅ Paso 3: Método matchesEntityReferenceFilters
java
Copiar
Editar
private boolean matchesEntityReferenceFilters(Object entity, Class<?> targetClass) {
    for (Field field : getAllFieldsReferencing(targetClass)) {
        EntityReference ref = field.getAnnotation(EntityReference.class);
        if (ref != null && ref.targetEntity().equals(targetClass)) {
            for (String filter : ref.filters()) {
                String[] parts = filter.split(":", 2);
                if (parts.length != 2) continue;

                String property = parts[0].trim();
                Object expectedValue = convert(parts[1].trim());

                Object actualValue = resolveProperty(entity, property);
                if (actualValue == null || !actualValue.equals(expectedValue)) {
                    return false;
                }
            }
        }
    }
    return true;
}
✅ Método auxiliar getAllFieldsReferencing
java
Copiar
Editar
private List<Field> getAllFieldsReferencing(Class<?> referencedClass) {
    return Arrays.stream(DFCReportDistribution.class.getDeclaredFields())
        .filter(f -> {
            EntityReference ref = f.getAnnotation(EntityReference.class);
            return ref != null && ref.targetEntity().equals(referencedClass);
        })
        .toList();
}
✅ Método convert(String)
java
Copiar
Editar
private Object convert(String value) {
    if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
        return Boolean.parseBoolean(value);
    }

    try {
        return Integer.parseInt(value);
    } catch (NumberFormatException ignored) {}

    try {
        return Long.parseLong(value);
    } catch (NumberFormatException ignored) {}

    return value; // fallback: keep as string
}










public Map<String, Object> extractFilters(Field field) {
    EntityReference ref = field.getAnnotation(EntityReference.class);
    Map<String, Object> filterMap = new HashMap<>();
    if (ref != null && ref.filters().length > 0) {
        for (String filter : ref.filters()) {
            String[] parts = filter.split(":", 2);
            if (parts.length == 2) {
                filterMap.put(parts[0], convert(parts[1]));
            }
        }
    }
    return filterMap;
}



private String resolveMaxValuePattern(Field field) {
    int precision = 0;
    int scale = 0;

    AttributeOverride override = modelClass.getAnnotation(AttributeOverride.class);
    if (override != null && override.name().equals(field.getName())) {
        precision = override.column().precision();
        scale = override.column().scale();
    } else {
        Column column = getColumnAnnotation(field);
        if (column != null) {
            precision = column.precision();
            scale = column.scale();
        }
    }

    if (precision == 0) {
        return ""; // sin restricción
    }

    int integerDigits = precision - scale;
    if (integerDigits <= 0) {
        integerDigits = 1; // al menos 1 dígito entero
    }

    StringBuilder pattern = new StringBuilder();
    for (int i = 0; i < integerDigits; i++) {
        pattern.append("9");
    }

    if (scale > 0) {
        pattern.append(".");
        for (int i = 0; i < scale; i++) {
            pattern.append("9");
        }
    }

    return pattern.toString(); // ejemplo: "9999.9999"
}




public int getDecimalPlaces() {
    return scale;
}

public String getMaxValuePattern() {
    int integerDigits = precision - scale;
    StringBuilder pattern = new StringBuilder();
    for (int i = 0; i < integerDigits; i++) {
        pattern.append("9");
    }
    if (scale > 0) {
        pattern.append(".");
        for (int i = 0; i < scale; i++) {
            pattern.append("9");
        }
    }
    return pattern.toString(); // e.g. "9999.9999"
}



public boolean isIntegerType() {
    return (type == Integer.class || type == int.class || type == Long.class || type == long.class)
            && !readOnly;
}

public boolean isDecimalType() {
    return type == BigDecimal.class && !readOnly;
}


public boolean isDecimalType() {
    return (type == BigDecimal.class || type == Double.class || type == Float.class) && !readOnly;
}



private Object convertToFieldType(Field field, Object value) {
    if (!(value instanceof String strValue)) {
        return value;
    }

    Class<?> targetType = field.getType();

    try {
        strValue = strValue.replace(",", "").trim(); // elimina separador de miles

        if (targetType == BigDecimal.class) {
            return new BigDecimal(strValue);
        } else if (targetType == Double.class || targetType == double.class) {
            return Double.parseDouble(strValue);
        } else if (targetType == Float.class || targetType == float.class) {
            return Float.parseFloat(strValue);
        } else if (targetType == Long.class || targetType == long.class) {
            return Long.parseLong(strValue);
        } else if (targetType == Integer.class || targetType == int.class) {
            return Integer.parseInt(strValue);
        } else if (targetType == Short.class || targetType == short.class) {
            return Short.parseShort(strValue);
        }
    } catch (NumberFormatException e) {
        logger.warn("Could not convert value [{}] to type [{}] for field [{}]",
                strValue, targetType.getSimpleName(), field.getName());
    }

    return value; // fallback si no pudo convertir
}
